[
  
  {
    "title"    : "Insert Delete GetRandom in 0(1)",
    "category" : "",
    "tags"     : " cpp, std-unordered-map, std-unordered-set",
    "url"      : "/algoguru/2024/04/10/insert-delete-GetRandom-0(1).html",
    "date"     : "April 10, 2024",
    "excerpt"  : "https://leetcode.com/problems/insert-delete-getrandom-o1/\n\nSource\n\n\n    bool insert_dicvec(int val) {\n        auto itD = pDic-&amp;gt;find(val);\n        if (itD != end(*pDic)) return false;\n        pV-&amp;gt;push_back(val);\n        (*pDic)[val] = pV-&amp;gt;...",
  "content"  : "https://leetcode.com/problems/insert-delete-getrandom-o1/\n\nSource\n\n\n    bool insert_dicvec(int val) {\n        auto itD = pDic-&amp;gt;find(val);\n        if (itD != end(*pDic)) return false;\n        pV-&amp;gt;push_back(val);\n        (*pDic)[val] = pV-&amp;gt;size() - 1;\n        return true;\n    }\n\n    bool insert_hash(int val) {\n        auto it = pHash-&amp;gt;find(val);\n        if (it != end(*pHash)) return false;\n        pHash-&amp;gt;emplace(val);\n        return true;\n    }\n\n    bool remove_dicvec(int val) {\n        auto itD = pDic-&amp;gt;find(val);\n        if (itD == end(*pDic)) return false;\n        (*pV)[itD-&amp;gt;second] = pV-&amp;gt;back();\n        (*pDic)[pV-&amp;gt;back()] = itD-&amp;gt;second;\n        pV-&amp;gt;pop_back();\n        pDic-&amp;gt;erase(val);\n        return true;\n    }\n\n    bool remove_hash(int val) {\n        auto it = pHash-&amp;gt;find(val);\n        if (it == end(*pHash)) return false;\n        pHash-&amp;gt;erase(val);\n        return true;\n    }\n\n    int getRandom_dicvec() {\n        if (pV-&amp;gt;size() == 0) return -1;\n        return (*pV)[rand() % pV-&amp;gt;size()];\n    }\n\n    int getRandom_hash() {\n        if (pHash-&amp;gt;size() == 0) return -1;\n        int r = std::rand() / ((RAND_MAX + 1u) / pHash-&amp;gt;size());\n        auto it = begin(*pHash);\n        for (; it != end(*pHash); ++it) {\n            if (r-- == 0) break;\n        }\n        return *it;\n    }\n\n\n\nGitHub\n\n\n  InsertDeleteGetRandomO1\n\n\n\n"
} ,
  
  {
    "title"    : "H Index",
    "category" : "",
    "tags"     : " cpp, sort, binning",
    "url"      : "/algoguru/2024/03/28/h-index.html",
    "date"     : "March 28, 2024",
    "excerpt"  : "https://leetcode.com/problems/h-index/\n\nSource\n\n\n    int hIndex(vector&amp;lt;int&amp;gt;&amp;amp; citations) {\n        int max_cit = 0;\n        for (const int&amp;amp; cit : citations) {\n            if (cit &amp;gt; max_cit) max_cit = cit;\n        }\n        vi bins ...",
  "content"  : "https://leetcode.com/problems/h-index/\n\nSource\n\n\n    int hIndex(vector&amp;lt;int&amp;gt;&amp;amp; citations) {\n        int max_cit = 0;\n        for (const int&amp;amp; cit : citations) {\n            if (cit &amp;gt; max_cit) max_cit = cit;\n        }\n        vi bins = create_bins(citations, max_cit+1);\n        int h_idx = 0;\n        int cnt = 0;\n        FOR_DEC(cit, 0, bins.size()) {\n            cnt += bins[cit];\n            if (cit &amp;lt;= cnt) {\n                h_idx = cit;\n                break;\n            }\n        }\n        return h_idx;\n    }\n    vi create_bins(const vi&amp;amp; data, int bin_size) {\n        vi bins(bin_size, 0);\n        for (const int&amp;amp; d : data) {\n            if (d &amp;lt; bin_size) bins[d]++;\n        }\n        return bins;\n    }\n\n    int hIndex_sort(vector&amp;lt;int&amp;gt;&amp;amp; citations) {\n        sort (begin(citations), end(citations), std::greater&amp;lt;&amp;gt;());\n        int h = 0;\n        int cnt = 1;\n        for (const int&amp;amp; c: citations) {\n            if (c &amp;gt;= cnt) h = cnt;\n            else break;\n            cnt++;\n        }\n        return h;\n    }\n\n\n\nGitHub\n\n\n  HIndex\n\n\n\n"
} ,
  
  {
    "title"    : "Cheatsheet",
    "category" : "",
    "tags"     : " interview, cheetsheet",
    "url"      : "/algoguru/blogging/2024/03/28/cheatsheet.html",
    "date"     : "March 28, 2024",
    "excerpt"  : "\n\nCheatsheets\n\nThis article will be a collection of cheat sheets that you can use as you solve problems and prepare for interviews. You will find:\n\n  Time complexity (Big O) cheat sheet\n  General DS/A flowchart (when to use each DS/A)\n  Stages of ...",
  "content"  : "\n\nCheatsheets\n\nThis article will be a collection of cheat sheets that you can use as you solve problems and prepare for interviews. You will find:\n\n  Time complexity (Big O) cheat sheet\n  General DS/A flowchart (when to use each DS/A)\n  Stages of an interview cheat sheet\n\n\nTime complexity (Big O) cheat sheet\n\n\n\n"
} ,
  
  {
    "title"    : "Stages Of An Interview",
    "category" : "",
    "tags"     : " interview",
    "url"      : "/algoguru/blogging/2024/02/28/stages-of-an-interview.html",
    "date"     : "February 28, 2024",
    "excerpt"  : "\n\nStages of an interview\n\nMost algorithmic interview rounds are between 45 - 60 minutes. The interviews can be broken down into stages, and at each stage, there are multiple things you should do to maximize your chances of success. Let’s break it ...",
  "content"  : "\n\nStages of an interview\n\nMost algorithmic interview rounds are between 45 - 60 minutes. The interviews can be broken down into stages, and at each stage, there are multiple things you should do to maximize your chances of success. Let’s break it down.\n\n1. Introductions\n\nAt the start of the interview, most of the time your interviewer will briefly introduce themselves and their role at the company, then ask you to introduce yourself.\n\n\n  Prepare and rehearse a brief introduction of yourself. It should summarize your education, work experience, and interests in 30-60 seconds.\n  Smile and speak with a confident voice.\n  When the interviewer is talking about their work at the company, pay attention - it will help to ask questions about it later.\n  If the interviewer mentioned anything that you are also interested in, whether it be their work or a hobby, mention it.\n\n\n2. Problem statement\n\nAfter introductions, your interviewer will give you a problem statement. If you’re working in a shared text editor, they will most likely paste the problem description along with a test case into the editor, and then read the question to you.\n\n\n  Make sure you fully understand the problem. After the interviewer has read the problem over, confirm what the problem is asking by paraphrasing it back to them.\n  Ask clarifying questions regarding the input, for example:\n    \n      Will the input only have integers, or could there be other types?\n      Will the input be sorted or unsorted?\n      Is the input guaranteed to have elements or could it be empty?\n      What should I do if an invalid input is given?\n    \n  \n  Ask about the expected input size. Sometimes, the interviewer will be vague, but if they do give you a range, it can be a clue. For example, if \\(n\\) is very small, it is likely backtracking. If \\(n\\) is around \\(100 - 1000\\) , an \\(O(n^2)\\) solution might be optimal. If \\(n\\) is very large, then you might need to do better than \\(O(n)\\).\n  The interviewer will likely give you one or two example test cases. Quickly walk through one to confirm that you understand the problem.\n\n\n\n  Asking clarifying questions not only helps you better understand the problem but also shows attention to detail and being considerate of things like edge cases.\n\n\n3. Brainstorming DS&amp;amp;A\n\nTry to figure out what data structure or algorithm is applicable. Break the problem down and try to find common patterns that you’ve learned. Figure out what the problem needs you to do, and think about what data structure or algorithm can accomplish it with a good time complexity.\n\nThink out loud. It will show your interviewer that you are good at considering tradeoffs. If the problem involves looking at subarrays, then be vocal about considering a sliding window because every window represents a subarray. Even if you’re wrong, the interviewer will still appreciate your thought process.\n\nThe best way to train this skill is to practice LeetCode problems.\n\n\n  By thinking out loud, you also open the door for the interviewer to give you hints and point you in the right direction.\n\n\nOnce you have decided on what data structures/algorithms to use, you now need to construct your actual algorithm. Before coding, you should think of the rough steps of the algorithm, explain them to the interviewer, and make sure they understand and agree that it is a reasonable approach. Usually, if you are on the wrong path, they will subtly hint at it.\n\n\n  It is extremely important that you are receptive to what the interviewer says at this stage. Remember: they know the optimal solution. If they are giving you a hint, it is because they want you to succeed. Don’t be stubborn and be ready to explore the ideas they give you.\n\n\n4. Implementation\n\nOnce you have come up with an algorithm and gotten the interviewer on board, it is time to start writing code.\n\n\n  If you intend on using a library or module like Python’s collections for example, make sure the interviewer is ok with it before importing it.\n  As you implement, explain your decision-making. For example, if you are solving a graph problem, when you declare a set \\(seen\\), explain that it is to prevent visiting the same node more than once, thus also preventing cycles.\n  Write clean code. Every major programming language has a convention for how code should be written. Make sure you know the basics of the language that you plan to be using. Google provides a summary for all major languages. The most important sections are case conventions, indentations, spacing, and global variables.\n  Avoid duplicated code. For example, if you are doing a DFS on a matrix, loop over a directions array \\([(0, 1), (1, 0), (0, -1), (-1, 0)]\\) instead of writing the same logic 4 times for each direction. If you find yourself writing similar code in multiple places, consider creating a function or simplifying it with a loop.\n  Don’t be scared of using helper functions. They make your code more modular, which is very important in real software engineering. It might also make potential follow-ups easier.\n\n\nDon’t panic if you get stuck or realize that your original plan might not work. Communicate your concerns with your interviewer. It makes their life a lot harder if you are struggling in silence.\n\nOne strategy is to first implement a brute force solution while acknowledging that it is a suboptimal solution. Once it is completed, analyze each part of the algorithm, figure out what steps are “slow”, and try to think about how it can be sped up. Engage your interviewer and include them in the discussion - they want to help.\n\n5. Testing &amp;amp; debugging\n\nOnce you have finished coding, your interviewer will likely want to test your code. Depending on the company, there are a few different environments your interview might be taking place in:\n\n\n  Built-in test cases, code is run\n    \n      These platforms are similar to LeetCode. There will be a wide variety of test cases - small inputs, huge inputs, inputs that test edge cases.\n      This environment puts the most stress on your code because a non-perfect solution will be exposed.\n      However, it also puts the least stress on creating your own tests, since they are already built-in.\n    \n  \n  Write your own test cases, code is run\n    \n      These platforms are usually shared text editors that support running code. The interviewer will want you to write your own test cases.\n      To actually test the code, you should write in the outermost scope of the code, wherever the code will get run first. Assuming you solved the problem in a function (like on LeetCode), you can call your function with the test cases you wrote and print the results to the console.\n      When writing your own tests, make sure to try a variety. Include edge cases, intuitive inputs, and possibly invalid inputs (if the interviewer wants you to handle that case).\n    \n  \n  Write your own test cases, code is not run\n    \n      These platforms will just be shared text editors that do not support running code. The interviewer will want you to write your own test cases and walk through them manually.\n      To “test” the code, you will have to go through the algorithm manually with each test case. Try to condense trivial parts - for example, if you’re creating a prefix sum, don’t literally walk through the for loop with every element. Say something along the lines of “after this for loop, we will have a prefix sum which will look like …”.\n      As you are walking through the code, write (in the editor, outside your function somewhere) the variables used in the function and continuously update them.\n    \n  \n\n\nRegardless of the scenario, if it turns out your code has an error, don’t panic! If the environment supports running code, put print statements in relevant locations to try to identify the issue. Walk through a test case manually (as you would if you have an environment without runtime support) with a small test case. As you do it, talk about what the expected values of the variables should be and compare them with what they actually are. Again, the more vocal you are, the easier it is for the interviewer to help you.\n\n6. Explanations and follow-ups\n\nAfter coding the algorithm and running through test cases, be prepared to answer questions regarding your algorithm. Questions you should always expect and be ready for include:\n\n\n  What is the time and space complexity of the algorithm?\n    \n      You should speak in terms of the worst-case scenario. However, if the worst case is rare and the average case has a significantly faster runtime, you should also mention this.\n    \n  \n  Why did you choose to do …?\n    \n      This could be your choice of data structure, choice of algorithm, choice of for loop configurations, etc. Be prepared to explain your thought process.\n    \n  \n  Do you think that the algorithm could be improved in terms of time or space complexity?\n    \n      If the problem needs to look at every element in the input (let’s say the input isn’t sorted and you needed to find the max element), then you probably can’t do better than \\(O(n)\\). Otherwise, you probably can’t do better than \\(O(log n)\\).\n      If the interviewer asks this, the answer is usually yes. Be careful about asserting that your algorithm is optimal - it’s ok to be wrong, but it’s not ok to be confidently wrong.\n    \n  \n\n\nIf there is time remaining in the interview, you may be asked an entirely new question. In that case, restart from step 2 (Problem statement). However, you may also be asked follow-ups to the question you already solved. The interviewer might introduce new constraints, ask for an improved space complexity, or any other number of things.\n\n\n  This section is why it is important to actually understand solutions and not just memorize them.\n\n\n7. Outro\n\nThe interviewer will usually reserve a few minutes at the end of the interview to allow you to ask questions about them or the company. You will rarely be able to improve the outcome of the interview at this point, but you can certainly make it worse.\n\nInterviews are a two-way street. You should use this time as an opportunity to also get to know the company and see if you would like to work there. You should prepare some questions before the interview, such as:\n\n\n  What does an average day look like?\n  Why did you decide to join this company instead of another one?\n  What is your favorite and least favorite thing about the job?\n  What kind of work can I expect to work on?\n\n\nAll big companies will have their own tech blog. A great way to demonstrate your interest in the company is to read some blog posts and compile a list of questions regarding why the company makes the decisions they do.\n\nBe interested, keep smiling, listen to the interviewer’s responses, and ask follow-up questions to show that you understand their answers.\n\nIf you don’t have quality questions or appear bored/uninterested, it could give a bad signal to the interviewer. It doesn’t matter how well you did on the technical portion if the interviewer doesn’t like you in the end.\n\n"
} ,
  
  {
    "title"    : "3. Longest Substring Without Repeating Characters",
    "category" : "",
    "tags"     : " cpp, simple-implementation, dynamic-programming, two-pointers, greedy, mathematics, iomanip-setw, combination, permutation, std-next_permutation, big-number, greedy-alogrithm, dfs, dfs-pitfall, dfs-with-backtracking, bfs, bfs-with-generations, flood-fill, floyd-warshall, dijkstra, edit-distance, sort, kmp, rolling-hash, string-manipulation, string-find_if, string-find_first_of, string-replace, string-find, string-substr, unique-and-erase-vector, split-string, linked-list, std-cin-ignore, std-cin-get, std-stringstream, std-unordered-map, std-map, std-unordered-set, std-set, std-list, std-stack, std-queue, std-priority-queue, avoid-nested-loop, binary-search-tree, binary-search, radix-conversion, back_inserter",
    "url"      : "/algoguru/2023/03/27/longest-substring-without-repeating-characters.html",
    "date"     : "March 27, 2023",
    "excerpt"  : "https://leetcode.com/problems/longest-substring-without-repeating-characters/\n\nSource\n\n\n\n\n\n\nGitHub\n\n\n  LongestSubstringWithoutRepeatingCharacters\n\n\n\n",
  "content"  : "https://leetcode.com/problems/longest-substring-without-repeating-characters/\n\nSource\n\n\n\n\n\n\nGitHub\n\n\n  LongestSubstringWithoutRepeatingCharacters\n\n\n\n"
} ,
  
  {
    "title"    : "680. Valid Palindrome II",
    "category" : "",
    "tags"     : " cpp, simple-implementation, dfs, dfs-with-backtracking, string-manipulation",
    "url"      : "/algoguru/2023/03/27/valid-palindrome-2.html",
    "date"     : "March 27, 2023",
    "excerpt"  : "https://leetcode.com/problems/valid-palindrome-ii\n\nSource\n\n\n    bool validPalindrome(string s) {\n        is_valid_ = false;\n        DFS(s, 0, s.size()-1, 1);\n        return is_valid_;\n    }\n    void DFS(const string &amp;amp;s, const int i, const int ...",
  "content"  : "https://leetcode.com/problems/valid-palindrome-ii\n\nSource\n\n\n    bool validPalindrome(string s) {\n        is_valid_ = false;\n        DFS(s, 0, s.size()-1, 1);\n        return is_valid_;\n    }\n    void DFS(const string &amp;amp;s, const int i, const int j, const int c) {\n        if (i&amp;gt;=j) is_valid_ = true;\n        if (is_valid_) return;\n        if (s[i] == s[j]) DFS(s, i+1, j-1, c);\n        else if (c &amp;gt; 0) {\n            DFS(s, i+1, j, c-1);\n            DFS(s, i, j-1, c-1);\n        }\n        else return;\n    }\n\n    bool validPalindrome_simple(string s) {\n        const int s_size = s.size();\n        int skipcnt = 1;\n        int tmpi=0;\n        int tmpj=0;\n        for (int i=0, j=s_size-1-i, lim=65432; i&amp;lt;j &amp;amp;&amp;amp;lim ;--lim) {\n            if (s[i] == s[j]) {\n                ++i;\n                --j;\n            }\n            else if (skipcnt &amp;gt; 0){\n                tmpi = i;\n                tmpj = j;\n                if (s[i+1] == s[j]) {\n                    ++i;\n                }\n                else if (s[i] == s[j-1]) {\n                    --j;\n                }\n                else return false;\n                skipcnt--;\n            }\n            else if (skipcnt == 0) {\n                i=tmpi;\n                j=tmpj;\n                --j;\n                skipcnt--;\n            }\n            else return false;\n        }\n        return true;\n    }\n\n\n\nGitHub\n\n\n  ValidPalindrome2\n\n"
} ,
  
  {
    "title"    : "125. Valid Palindrome",
    "category" : "",
    "tags"     : " cpp, simple-implementation, string-manipulation",
    "url"      : "/algoguru/2023/03/27/valid-palindrome.html",
    "date"     : "March 27, 2023",
    "excerpt"  : "https://leetcode.com/problems/valid-palindrome\n\nSource\n\n\n    bool isPalindrome(string s) {\n        string p;\n        for (auto c : s) {\n            if (c &amp;gt;=&#39;A&#39; &amp;amp;&amp;amp; c &amp;lt;= &#39;Z&#39;) p.push_back(c-&#39;A&#39;+&#39;a&#39;);\n            else if ((c &amp;gt;= &#39;a&#39; &amp;a...",
  "content"  : "https://leetcode.com/problems/valid-palindrome\n\nSource\n\n\n    bool isPalindrome(string s) {\n        string p;\n        for (auto c : s) {\n            if (c &amp;gt;=&#39;A&#39; &amp;amp;&amp;amp; c &amp;lt;= &#39;Z&#39;) p.push_back(c-&#39;A&#39;+&#39;a&#39;);\n            else if ((c &amp;gt;= &#39;a&#39; &amp;amp;&amp;amp; c &amp;lt;= &#39;z&#39;) || (c &amp;gt;= &#39;0&#39; &amp;amp;&amp;amp; c &amp;lt;= &#39;9&#39;)) p.push_back(c);\n            else continue;\n        }\n        const int p_size = p.size();\n        const int loop = static_cast&amp;lt;int&amp;gt;(p_size*0.5);\n        for (int i=0; i&amp;lt;loop; ++i) {\n            if (p[i] == p[p_size-1-i]) continue;\n            else return false;\n        }\n        return true;\n    }\n\n\n\nGitHub\n\n\n  ValidPalindrome\n\n"
} ,
  
  {
    "title"    : "28. Find the Index of the First Occurrence in a String",
    "category" : "",
    "tags"     : " cpp, string-manipulation, string-find, string-substr, kmp, rolling-hash",
    "url"      : "/algoguru/2023/03/26/str-str.html",
    "date"     : "March 26, 2023",
    "excerpt"  : "https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string\n\nSource\n\n\n    int strStr_STD(string haystack, string needle) {\n        int idx = haystack.find(needle);\n        if (idx == std::string::npos) return -1;\n        retur...",
  "content"  : "https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string\n\nSource\n\n\n    int strStr_STD(string haystack, string needle) {\n        int idx = haystack.find(needle);\n        if (idx == std::string::npos) return -1;\n        return idx;\n    }\n\n    int strStr_Rabin_Karp(string haystack, string needle) {\n        const int key_hash = hash(needle);\n        const int key_size = needle.size();\n        if (key_size &amp;lt;= haystack.size()) {\n            for (int i=0; i&amp;lt;haystack.size()-key_size+1; ++i) {\n                const string hs = haystack.substr(i, key_size);\n                if (key_hash == hash(hs)) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n    int hash(string str) {\n        int sum = 0;\n        for (const auto c : str) {\n            sum += c-&#39;a&#39;;\n        }\n        return std::hash&amp;lt;std::string&amp;gt;{}(str)*sum;\n    }\n\n    int strStr_KMP(string haystack, string needle) {\n        /*/\n        vector&amp;lt;int&amp;gt; lps = kmp_prepare(needle);\n        return kmp_search(haystack, needle, lps);\n        /*/\n        vector&amp;lt;int&amp;gt; lps = longest_proper_suffix(needle);\n        return kmp_process(haystack, needle, lps);\n        //*/\n    }\n\n    vector&amp;lt;int&amp;gt; longest_proper_suffix(const string &amp;amp;P) {\n        const int p = P.size();\n        vector&amp;lt;int&amp;gt; lps(p, 0);\n        for (int i=1, len=0, lim=INF; i &amp;lt; p &amp;amp;&amp;amp;lim&amp;gt;0;--lim) {\n            if (P[i] == P[len]) {\n                lps[i++] = ++len;\n            } else if (len &amp;gt; 0) {\n                len = lps[len-1];\n            } else {\n                lps[i++] = 0;\n            }\n        }\n        return lps;\n    }\n    int kmp_process(const string &amp;amp;T, const string &amp;amp;P, const vector&amp;lt;int&amp;gt; &amp;amp;lps) {\n        const int t = T.size();\n        const int p = P.size();\n        if (t==0) return 0;\n\n        for (int i=0, j=0, lim=INF; i &amp;lt; t &amp;amp;&amp;amp;lim&amp;gt;0;--lim) {\n            if (T[i] == P[j]) {i++, j++;}\n            if (j == p) return i-j;\n            if (i &amp;lt; t &amp;amp;&amp;amp; T[i] != P[j]) {\n                j ? j = lps[j-1] : i++;\n            }\n        }\n\n        return -1;\n    }\n\n    vector&amp;lt;int&amp;gt; kmp_prepare(const string &amp;amp;P) {\n        const int p = P.size();\n        vector&amp;lt;int&amp;gt; lps(p+1, 0);\n        lps[0] = -1;\n        int j=-1;\n        for (int i=0, lim=INF; i &amp;lt; p &amp;amp;&amp;amp;lim&amp;gt;0;--lim) {\n            for(;j&amp;gt;=0 &amp;amp;&amp;amp; P[i] != P[j] &amp;amp;&amp;amp;lim&amp;gt;0;--lim) {\n                j = lps[j];\n            }\n            ++i; ++j;\n            lps[i] = j;\n        }\n        return lps;\n    }\n    int kmp_search(const string &amp;amp;T, const string &amp;amp;P, const vector&amp;lt;int&amp;gt; &amp;amp;lps) {\n        const int t = T.size();\n        const int p = P.size();\n        int idx = -1;\n        for (int i=0,j=0, lim=INF; i &amp;lt; t &amp;amp;&amp;amp;lim&amp;gt;0;--lim) {\n            for (;j &amp;gt;= 0 &amp;amp;&amp;amp; T[i] != P[j]&amp;amp;&amp;amp;lim&amp;gt;0;--lim) {\n                j = lps[j];\n            }\n            ++i, ++j;\n            if (j == p) {\n                idx = i-j;\n                j = lps[j];\n                break;\n            }\n        }\n        return idx;\n    }\n\n\n\nGitHub\n\n\n  StrStr\n\n\n\n"
} ,
  
  {
    "title"    : "205. Isomorphic Strings",
    "category" : "",
    "tags"     : " cpp, simple-implementation, string-manipulation, string-replace, string-find, std-unordered-map",
    "url"      : "/algoguru/2023/03/13/isomorphic-strings.html",
    "date"     : "March 13, 2023",
    "excerpt"  : "https://leetcode.com/problems/isomorphic-strings\n\nSource\n\n\n    bool isIsomorphic(string s, string t) {\n        unordered_map&amp;lt;char, char&amp;gt; hashST;\n        unordered_map&amp;lt;char, char&amp;gt; hashTS;\n        bool isIsmp = true;\n        for (int i =...",
  "content"  : "https://leetcode.com/problems/isomorphic-strings\n\nSource\n\n\n    bool isIsomorphic(string s, string t) {\n        unordered_map&amp;lt;char, char&amp;gt; hashST;\n        unordered_map&amp;lt;char, char&amp;gt; hashTS;\n        bool isIsmp = true;\n        for (int i = 0; i &amp;lt; s.size(); ++i) {\n            const char c1 = s[i];\n            const char c2 = t[i];\n            if ((hashST.find(c1) == std::end(hashST)) &amp;amp;&amp;amp; (hashTS.find(c2) == std::end(hashTS))) {\n                hashST[c1] = c2;\n                hashTS[c2] = c1;\n            } else if (hashST[c1] == c2) {\n                // Do nothing\n            } else {\n                isIsmp = false;\n                break;\n            }\n        }\n        return isIsmp;\n    }\n\n\n\nGitHub\n\n\n  IsomorphicStrings\n\n\n\n"
} ,
  
  {
    "title"    : "392. Is Subsequence",
    "category" : "",
    "tags"     : " cpp, simple-implementation, string-manipulation",
    "url"      : "/algoguru/2023/03/13/is-subsequence.html",
    "date"     : "March 13, 2023",
    "excerpt"  : "https://leetcode.com/problems/is-subsequence\n\nSource\n\n\n    bool isSubsequence(string s, string t) {\n        if (s.size() == 0) return true;\n        bool isSubsq = false;\n        int i = 0;\n        for (const auto &amp;amp;c : t) {\n            if (c ==...",
  "content"  : "https://leetcode.com/problems/is-subsequence\n\nSource\n\n\n    bool isSubsequence(string s, string t) {\n        if (s.size() == 0) return true;\n        bool isSubsq = false;\n        int i = 0;\n        for (const auto &amp;amp;c : t) {\n            if (c == s[i]) {\n                ++i;\n                if (s.size() == i) {\n                    isSubsq = true;\n                    break;\n                } else\n                    continue;\n            }\n        }\n        return isSubsq;\n    }\n\n\n\nGitHub\n\n\n  IsSubsequence\n\n\n\n"
} ,
  
  {
    "title"    : "415. Add Strings",
    "category" : "",
    "tags"     : " cpp, simple-implementation, string-manipulation",
    "url"      : "/algoguru/2023/03/13/add-strings.html",
    "date"     : "March 13, 2023",
    "excerpt"  : "https://leetcode.com/problems/add-strings\n\nSource\n\n\n    string addStrings(string num1, string num2) {\n        std::string ans;\n        int carry = 0;\n        auto it1 = std::rbegin(num1), it2 = std::rbegin(num2);\n        for (int i=0; i&amp;lt;INF; ++...",
  "content"  : "https://leetcode.com/problems/add-strings\n\nSource\n\n\n    string addStrings(string num1, string num2) {\n        std::string ans;\n        int carry = 0;\n        auto it1 = std::rbegin(num1), it2 = std::rbegin(num2);\n        for (int i=0; i&amp;lt;INF; ++i) {\n            bool inc1 = false;\n            bool inc2 = false;\n            if (it1 != std::rend(num1)) inc1 = true;\n            if (it2 != std::rend(num2)) inc2 = true;\n\n            if (!inc1 and !inc2) break;\n\n            const int n1 = inc1? (*it1) - &#39;0&#39; : 0;\n            const int n2 = inc2? (*it2) - &#39;0&#39; : 0;\n            int sum = n1 + n2 + carry;\n            carry = 0;\n            if (sum &amp;gt; 9) {\n                carry = 1;\n                sum %= 10;\n            }\n\n            ans = std::to_string(sum) + ans;\n\n            if (inc1) ++it1;\n            if (inc2) ++it2;\n        }\n        if (carry &amp;gt; 0) ans = std::to_string(carry) + ans;\n        return ans;\n    }\n\n\n\nGitHub\n\n\n  AddStrings\n\n"
} ,
  
  {
    "title"    : "724. Find Pivot Index",
    "category" : "",
    "tags"     : " cpp, simple-implementation, prefix-sum",
    "url"      : "/algoguru/2023/03/02/find-pivot-index.html",
    "date"     : "March 2, 2023",
    "excerpt"  : "https://leetcode.com/problems/find-pivot-index\n\nSource\n\n\n    int pivotIndex(vector&amp;lt;int&amp;gt;&amp;amp; nums) {\n        int pivot = -1;\n        int right_sum = 0;\n        for (const auto &amp;amp;n : nums) {\n            right_sum += n;\n        }\n        in...",
  "content"  : "https://leetcode.com/problems/find-pivot-index\n\nSource\n\n\n    int pivotIndex(vector&amp;lt;int&amp;gt;&amp;amp; nums) {\n        int pivot = -1;\n        int right_sum = 0;\n        for (const auto &amp;amp;n : nums) {\n            right_sum += n;\n        }\n        int left_sum = 0;\n        for (int i=0; i&amp;lt;nums.size(); ++i) {\n            right_sum -= nums[i];\n            if (right_sum == left_sum) {\n                pivot = i;\n                break;\n            }\n            left_sum += nums[i];\n        }\n        return pivot;\n    }\n\n\n\nGitHub\n\n\n  FindPivotIndex\n\n\n\n"
} ,
  
  {
    "title"    : "409. Longest Palindrome",
    "category" : "",
    "tags"     : " cpp, simple-implementation, std-unordered-map",
    "url"      : "/algoguru/2023/02/20/longest-palindrome.html",
    "date"     : "February 20, 2023",
    "excerpt"  : "https://leetcode.com/problems/longest-palindrome/\n\nSource\n\n\n    int longestPalindrome(string s) {\n        unordered_map&amp;lt;char, int&amp;gt; hashMap;\n        for (char c : s) {\n            hashMap[c]++;\n        }\n        int oneside = 0;\n        int a...",
  "content"  : "https://leetcode.com/problems/longest-palindrome/\n\nSource\n\n\n    int longestPalindrome(string s) {\n        unordered_map&amp;lt;char, int&amp;gt; hashMap;\n        for (char c : s) {\n            hashMap[c]++;\n        }\n        int oneside = 0;\n        int addOne = 0;\n        for (auto it=std::begin(hashMap); std::end(hashMap)!=it; ++it) {\n            const char c = it-&amp;gt;first;\n            const int num = hashMap[c];\n            const int half = static_cast&amp;lt;int&amp;gt;(num/2);\n            if (half &amp;gt; 0) oneside += half;\n            if (num%2 &amp;gt; 0) addOne = 1;\n        }\n        return (2*oneside + addOne);\n    }\n\n\n\n\nGitHub\n\n\n  LongestPalindrome\n\n\n\n"
} ,
  
  {
    "title"    : "219. Contains Duplicate II",
    "category" : "",
    "tags"     : " cpp, std-unordered-map",
    "url"      : "/algoguru/2023/02/20/contains-duplicate-2.html",
    "date"     : "February 20, 2023",
    "excerpt"  : "https://leetcode.com/problems/contains-duplicate-ii/\n\nSource\n\n\n    bool containsNearbyDuplicate(const vector&amp;lt;int&amp;gt;&amp;amp; nums, int k) {\n        unordered_map&amp;lt;int, int&amp;gt; hash;\n        for (int i=0; i&amp;lt;nums.size(); ++i) {\n            if (...",
  "content"  : "https://leetcode.com/problems/contains-duplicate-ii/\n\nSource\n\n\n    bool containsNearbyDuplicate(const vector&amp;lt;int&amp;gt;&amp;amp; nums, int k) {\n        unordered_map&amp;lt;int, int&amp;gt; hash;\n        for (int i=0; i&amp;lt;nums.size(); ++i) {\n            if (++hash[nums[i]] &amp;gt; 1) return true;\n            if (i&amp;gt;=k) hash[nums[i-k]] = 0;\n        }\n        return false;\n    }\n\n\n\nGitHub\n\n\n  ContainsDuplicate2\n\n\n\n"
} ,
  
  {
    "title"    : "283. Move Zeroes",
    "category" : "",
    "tags"     : " cpp, simple-implementation",
    "url"      : "/algoguru/2022/04/12/move-zeros.html",
    "date"     : "April 12, 2022",
    "excerpt"  : "https://leetcode.com/problems/move-zeroes/\n\nSource\n\n\n    void moveZeroes(vector&amp;lt;int&amp;gt;&amp;amp; nums) {\n        FOR(i, nums.size()) {\n            const int I = nums[i];\n            if (I != 0) continue;\n            // I is zero\n            FOR_INC...",
  "content"  : "https://leetcode.com/problems/move-zeroes/\n\nSource\n\n\n    void moveZeroes(vector&amp;lt;int&amp;gt;&amp;amp; nums) {\n        FOR(i, nums.size()) {\n            const int I = nums[i];\n            if (I != 0) continue;\n            // I is zero\n            FOR_INC(j, i+1, nums.size()) {\n                const int J = nums[j];\n                if (J == 0) continue;\n                // J is non-zero\n                nums[i] = J;\n                nums[j] = 0;\n                break;\n            }\n        }\n    }\n\n\n\nGitHub\n\n\n  MoveZeros\n\n\n\n"
} ,
  
  {
    "title"    : "11. Container With Most Water",
    "category" : "",
    "tags"     : " cpp, two-pointers, tree",
    "url"      : "/algoguru/2022/04/12/max-area-contain-water.html",
    "date"     : "April 12, 2022",
    "excerpt"  : "https://leetcode.com/problems/container-with-most-water/\n\nSource\n\n\n    int maxArea(vector&amp;lt;int&amp;gt;&amp;amp; height) {\n        int maxA = 0;\n        /*/  brute force\n        FOR(i, height.size()) {\n            const int hI = height[i];\n            FO...",
  "content"  : "https://leetcode.com/problems/container-with-most-water/\n\nSource\n\n\n    int maxArea(vector&amp;lt;int&amp;gt;&amp;amp; height) {\n        int maxA = 0;\n        /*/  brute force\n        FOR(i, height.size()) {\n            const int hI = height[i];\n            FOR_INC(j, i+1, height.size()) {\n                const int hJ = height[j];\n                const int area = std::min(hI, hJ) * (j-i);\n                if (area &amp;gt; maxA) {\n                    maxA = area;\n                }\n            }\n        }\n        /*/\n        // Answer!\n        int l = 0, r = height.size()-1;\n        while(l&amp;lt;r) {\n            const int hL = height[l];\n            const int hR = height[r];\n            maxA = std::max(std::min(hL, hR)*(r-l), maxA);\n            if (hL &amp;lt; hR) l++;\n            else r--;\n        }\n        //*/\n        return maxA;\n    }\n\n\n\nGitHub\n\n\n  MaxAreaContainWater\n\n\n\n"
} ,
  
  {
    "title"    : "33. Search in Rotated Sorted Array",
    "category" : "",
    "tags"     : " cpp, binary-search",
    "url"      : "/algoguru/2022/04/10/search-rotated-sorted.html",
    "date"     : "April 10, 2022",
    "excerpt"  : "https://leetcode.com/problems/search-in-rotated-sorted-array/\n\nSource\n\n\n    int search(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) {\n        const int MAX_L = log2(nums.size()) + 3;\n        int hi=nums.size()-1;\n        int lo=0;\n        // /*/\n     ...",
  "content"  : "https://leetcode.com/problems/search-in-rotated-sorted-array/\n\nSource\n\n\n    int search(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) {\n        const int MAX_L = log2(nums.size()) + 3;\n        int hi=nums.size()-1;\n        int lo=0;\n        // /*/\n        int ans=-1;\n        for (int i=0; hi&amp;gt;=lo &amp;amp;&amp;amp; i&amp;lt;MAX_L; ++i) {\n            const int mid = (hi+lo) &amp;gt;&amp;gt; 1;\n            if (nums[mid] == target) {\n                ans = mid;\n                break;\n            }\n\n            if (nums[mid] &amp;gt;= nums[lo]) {\n                if (nums[mid] &amp;gt; target &amp;amp;&amp;amp; target &amp;gt;= nums[lo]) {\n                    hi = mid-1;\n                }\n                else {\n                    lo = mid+1;\n                }\n\n            }\n            else {\n                if (nums[hi] &amp;gt;= target &amp;amp;&amp;amp; target &amp;gt; nums[mid]) {\n                    lo = mid+1;\n                }\n                else {\n                    hi = mid-1;\n                }\n            }\n        }\n        /*/\n        bool beforePivot =  (nums[lo]&amp;gt;target) ? false : true;\n        if (nums[hi] &amp;lt; nums[lo]) {\n            for (int i=0; hi&amp;gt;lo &amp;amp;&amp;amp; i&amp;lt;MAX_L; ++i) {\n                const int mid = (hi+lo) &amp;gt;&amp;gt; 1;\n\n                if (nums[mid] &amp;gt; nums[mid+1]) {\n                    if (beforePivot) hi = mid;\n                    else lo = mid+1;\n                    break;\n                }\n                else if (nums[mid] &amp;gt;= nums[lo]) {\n                    lo = mid+1;\n                }\n                else {\n                    hi = mid-1;\n                }\n            }\n            if (beforePivot) lo = 0;\n            else hi = nums.size()-1;\n        }\n\n        int ans = -1;\n        for (int i=0; hi&amp;gt;=lo &amp;amp;&amp;amp; i&amp;lt;MAX_L; ++i) {\n            const int mid = (hi+lo) &amp;gt;&amp;gt; 1;\n            if (nums[mid] == target) {\n                ans = mid;\n                break;\n            }\n            else if (nums[mid] &amp;gt; target) {\n                //if (hi == mid)\n                    hi = mid-1;\n                //else hi = mid;  // nums[mid] == target 이 따로 존재할 경우 필요없음\n            }\n            else {\n                //if (lo == mid)\n                    lo = mid+1;\n                //else lo = mid;  // nums[mid] == target 이 따로 존재할 경우 필요없음\n            }\n        }\n        //*/\n\n        return ans;\n    }\n\n\n\nGitHub\n\n\n  SearchRotatedSorted\n\n\n\n"
} ,
  
  {
    "title"    : "34. Find First and Last Position of Element in Sorted Array",
    "category" : "",
    "tags"     : " cpp, binary-search",
    "url"      : "/algoguru/2022/03/31/find-first-last.html",
    "date"     : "March 31, 2022",
    "excerpt"  : "https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/\n\nSource\n\n\n    vector&amp;lt;int&amp;gt; searchRange(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) {\n        if (nums.empty()) return {-1, -1};\n        const int MAX_L = log2...",
  "content"  : "https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/\n\nSource\n\n\n    vector&amp;lt;int&amp;gt; searchRange(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) {\n        if (nums.empty()) return {-1, -1};\n        const int MAX_L = log2(nums.size())+3;\n\n        int hi=nums.size()-1;\n        int lo=0;\n        int min = -1;\n        for (int i=0; hi&amp;gt;=lo &amp;amp;&amp;amp; i&amp;lt;MAX_L; ++i) {\n            // if (!W_IFNOT(hi &amp;gt; -1)) break;\n            // if (!W_IFNOT(lo &amp;gt; -1)) break;\n            updateHiLoForMin(nums, target, (lo+hi)&amp;gt;&amp;gt;1, hi, lo, min);\n        }\n\n        nums.push_back(INF);\n        hi=nums.size()-1;\n        lo=max(0, min);\n        int max = -1;\n        for (int i=0; hi&amp;gt;=lo &amp;amp;&amp;amp; i&amp;lt;MAX_L; ++i) {\n            // if (!W_IFNOT(hi &amp;gt;= 0)) break;\n            // if (!W_IFNOT(lo &amp;gt;= 0)) break;\n            updateHiLoForMax(nums, target, (lo+hi)&amp;gt;&amp;gt;1, hi, lo, max);\n        }\n\n        vi viAns;\n        viAns.push_back(min);\n        viAns.push_back(max);\n\n        return viAns;\n    }\n\n    void updateHiLoForMin(const vi&amp;amp; nums, const int target, const int mid, int &amp;amp;hi, int &amp;amp;lo, int &amp;amp;min) {\n        // if (!W_IFNOT(mid &amp;lt;= hi)) return;\n        // if (!W_IFNOT(mid &amp;gt;= lo)) return;\n        if (nums[mid] == target) {\n            min = hi = mid;\n        }\n        else if (nums[mid] &amp;gt; target) {\n            if (hi == mid) hi = mid-1;\n            else hi = mid;\n        }\n        else {\n            if (lo == mid) lo = mid+1;\n            else lo = mid;\n        }\n    }\n\n    void updateHiLoForMax(const vi&amp;amp; nums, const int target, const int mid, int &amp;amp;hi, int &amp;amp;lo, int &amp;amp;max) {\n        // if (!W_IFNOT(mid &amp;lt;= hi)) return;\n        // if (!W_IFNOT(mid &amp;gt;= lo)) return;\n        if (nums[mid] == target) {\n            max = lo = mid;\n        }\n        else if (nums[mid] &amp;lt; target) {\n            if (lo == mid) lo = mid+1;\n            else lo = mid;\n        }\n        else {\n            if (hi == mid) hi = mid-1;\n            else hi = mid;\n        }\n    }\n\n\n\nGitHub\n\n\n  FindFirstLast\n\n"
} ,
  
  {
    "title"    : "1022. Sum of Root To Leaf Binary Numbers",
    "category" : "",
    "tags"     : " cpp, simple-implementation, dfs, binary-search-tree, radix-conversion",
    "url"      : "/algoguru/2022/03/29/sum-root-to-leaf.html",
    "date"     : "March 29, 2022",
    "excerpt"  : "https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/\n\nSource\n\n    int sumRootToLeaf(TreeNode* root) {\n        if (nullptr == root) return 0;\n\n        // root node has a value 0 or 1.\n        // root-to-leaf : binary number =&amp;gt; DFS, ...",
  "content"  : "https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/\n\nSource\n\n    int sumRootToLeaf(TreeNode* root) {\n        if (nullptr == root) return 0;\n\n        // root node has a value 0 or 1.\n        // root-to-leaf : binary number =&amp;gt; DFS, bin2dec\n        m_sum = 0;\n        DFS(root, &quot;&quot;);\n\n        // Return the sum of these numbers\n        return m_sum;\n    }\n\n    int bin2dec(const string strBin) {\n        const int lenBin = strBin.length();\n        int dec = 0;\n        for (int i=0; i&amp;lt;lenBin; ++i){\n            const int b = strBin[i]-&#39;0&#39;;\n            dec = (b + (dec &amp;lt;&amp;lt;= 1));\n        }\n        return dec;\n    }\n\n    void DFS(TreeNode* node, const string bin) {\n        if (nullptr == node) return;\n\n        const string strNum = to_string(node-&amp;gt;val);\n        const string newBin = bin + strNum;\n\n        if (nullptr == node-&amp;gt;left &amp;amp;&amp;amp; nullptr == node-&amp;gt;right) {\n            m_sum += bin2dec(newBin);\n            return;\n        }\n\n        DFS(node-&amp;gt;left, newBin);\n        DFS(node-&amp;gt;right, newBin);\n    }\n\n\nGitHub\n\n\n  SumRootToLeaf\n\n"
} ,
  
  {
    "title"    : "35. Search Insert Position",
    "category" : "",
    "tags"     : " cpp, simple-implementation, binary-search",
    "url"      : "/algoguru/2021/11/28/seach-insert-position.html",
    "date"     : "November 28, 2021",
    "excerpt"  : "https://leetcode.com/problems/search-insert-position/\n\nSource\n\n\n    int searchInsert(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) {\n        const int MAX_L = log2(nums.size())+3;\n        int ans = -1;\n        int hi=nums.size()-1, lo=0;\n        int mi...",
  "content"  : "https://leetcode.com/problems/search-insert-position/\n\nSource\n\n\n    int searchInsert(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) {\n        const int MAX_L = log2(nums.size())+3;\n        int ans = -1;\n        int hi=nums.size()-1, lo=0;\n        int mid = 0;\n        for (int i=0; (i&amp;lt;MAX_L) &amp;amp;&amp;amp; (hi&amp;gt;=lo); ++i) {\n            mid = (lo+hi) &amp;gt;&amp;gt; 1;\n            if (nums[mid] &amp;gt;= target) {\n                ans = mid;\n                if (hi == mid) hi = mid-1;\n                else hi = mid;\n            }\n            else {\n                if (lo == mid) lo = mid+1;\n                else lo = mid;\n            }\n        }\n        if (ans &amp;lt; 0) ans = mid + 1;\n\n        return ans;\n    }\n\n\nGitHub\n\n\n  SearchInsertPosition\n\n"
} ,
  
  {
    "title"    : "501. Find Mode in Binary Search Tree",
    "category" : "",
    "tags"     : " cpp, easy, sort, string-find, std-unordered-map",
    "url"      : "/algoguru/2021/11/01/find-mode.html",
    "date"     : "November 1, 2021",
    "excerpt"  : "https://leetcode.com/problems/find-mode-in-binary-search-tree/\n\nSource\n\n\n    vector&amp;lt;int&amp;gt; findMode(TreeNode* root) {\n\n        inorder(root);\n\n        vector&amp;lt;ii&amp;gt; viiModes;\n        auto it = begin(m_hashMap);\n        for (;it != end(m_has...",
  "content"  : "https://leetcode.com/problems/find-mode-in-binary-search-tree/\n\nSource\n\n\n    vector&amp;lt;int&amp;gt; findMode(TreeNode* root) {\n\n        inorder(root);\n\n        vector&amp;lt;ii&amp;gt; viiModes;\n        auto it = begin(m_hashMap);\n        for (;it != end(m_hashMap); it++) {\n            viiModes.push_back(ii(-it-&amp;gt;second, it-&amp;gt;first));\n        }\n\n        sort(begin(viiModes), end(viiModes));\n\n        vector&amp;lt;int&amp;gt; viAns;\n        int max = 0;\n        for (ii iiMode: viiModes) {\n            if (0 == max) {\n                viAns.push_back(iiMode.second);\n                max = -iiMode.first;\n            } else {\n                if (-iiMode.first == max) {\n                    viAns.push_back(iiMode.second);\n                    continue;\n                }\n                break;\n            }\n        }\n\n        return viAns;\n    }\n\n    void inorder(TreeNode* root) {\n        if (nullptr == root) return;\n\n        inorder(root-&amp;gt;left);\n\n        const int val = root-&amp;gt;val;\n        //*/\n        m_hashMap[val]++;   // It works!\n        /*/\n        auto itFound = m_hashMap.find(val);\n        if (end(m_hashMap) != itFound) {\n            itFound-&amp;gt;second++;\n        } else {\n            m_hashMap.insert(make_pair(val, 0));\n        }\n        //*/\n\n        inorder(root-&amp;gt;right);\n    }\n\n\n\nGitHub\n\n\n  FindMode\n\n"
} ,
  
  {
    "title"    : "690. Employee Importance",
    "category" : "",
    "tags"     : " cpp, dfs, std-unordered-map",
    "url"      : "/algoguru/2021/10/18/employee-importance.html",
    "date"     : "October 18, 2021",
    "excerpt"  : "https://leetcode.com/problems/employee-importance/\n\nSource\n\n\n    int getImportance(vector&amp;lt;Employee*&amp;gt; employees, int id) {\n        unordered_map&amp;lt;int, Employee*&amp;gt; hashE;\n        for (Employee* pEmp : employees) {\n            hashE.emplace...",
  "content"  : "https://leetcode.com/problems/employee-importance/\n\nSource\n\n\n    int getImportance(vector&amp;lt;Employee*&amp;gt; employees, int id) {\n        unordered_map&amp;lt;int, Employee*&amp;gt; hashE;\n        for (Employee* pEmp : employees) {\n            hashE.emplace(make_pair(pEmp-&amp;gt;id, pEmp));\n        }\n\n        return DFS(id, hashE);\n    }\n\n    int DFS(const int id, const unordered_map&amp;lt;int, Employee*&amp;gt;&amp;amp; hashE) {\n        if (hashE.empty()) return 0;\n\n        auto it = hashE.find(id);\n        if (it == end(hashE))  return 0;\n\n        int sumImp = 0;\n        for (int subId : it-&amp;gt;second-&amp;gt;subordinates) {\n            sumImp += DFS(subId, hashE);\n        }\n        return it-&amp;gt;second-&amp;gt;importance + sumImp;\n    }\n\n\n\nGitHub\n\n\n  EmployeeImportance\n\n\n\n"
} ,
  
  {
    "title"    : "623. Add One Row to Tree",
    "category" : "",
    "tags"     : " cpp, dfs",
    "url"      : "/algoguru/2021/10/18/add-one-row.html",
    "date"     : "October 18, 2021",
    "excerpt"  : "https://leetcode.com/problems/add-one-row-to-tree/\n\nSource\n\n\n    TreeNode* addOneRow(TreeNode* root, int val, int depth) {\n        if (1 == depth) {\n            TreeNode* node = new TreeNode(val, root, nullptr);\n            root = node;\n        }\n...",
  "content"  : "https://leetcode.com/problems/add-one-row-to-tree/\n\nSource\n\n\n    TreeNode* addOneRow(TreeNode* root, int val, int depth) {\n        if (1 == depth) {\n            TreeNode* node = new TreeNode(val, root, nullptr);\n            root = node;\n        }\n        else {\n            DFS(root, val, depth-1);\n        }\n        return root;\n    }\n\n    void DFS(TreeNode* cur, const int val, const int depth) {\n        if (nullptr == cur) return;\n        if (1 == depth) {\n            TreeNode* node = new TreeNode(val, cur-&amp;gt;left, nullptr);\n            cur-&amp;gt;left = node;\n            node = new TreeNode(val, nullptr, cur-&amp;gt;right);\n            cur-&amp;gt;right= node;\n        }\n\n        if (nullptr != cur-&amp;gt;left) DFS(cur-&amp;gt;left, val, depth-1);\n        if (nullptr != cur-&amp;gt;right) DFS(cur-&amp;gt;right, val, depth-1);\n    }\n\n\n\nGitHub\n\n\n  AddOneRow\n\n\n\n"
} ,
  
  {
    "title"    : "292. Nim Game",
    "category" : "",
    "tags"     : " cpp, mathematics",
    "url"      : "/algoguru/2021/10/09/nim-game.html",
    "date"     : "October 9, 2021",
    "excerpt"  : "https://leetcode.com/problems/nim-game/\n\nSource\n\n\n    bool canWinNim(int n) {\n        return n%4 == 0 ? false : true;\n    }\n\n\n\nGitHub\n\n\n  NimGame\n\n\n\n",
  "content"  : "https://leetcode.com/problems/nim-game/\n\nSource\n\n\n    bool canWinNim(int n) {\n        return n%4 == 0 ? false : true;\n    }\n\n\n\nGitHub\n\n\n  NimGame\n\n\n\n"
} ,
  
  {
    "title"    : "797. All Paths From Source to Target",
    "category" : "",
    "tags"     : " cpp, dfs",
    "url"      : "/algoguru/2021/10/09/all-paths-source-target.html",
    "date"     : "October 9, 2021",
    "excerpt"  : "https://leetcode.com/problems/all-paths-from-source-to-target/\n\nSource\n\n\n    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; allPathsSourceTarget(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; graph) {\n        vvi vviAns;\n        DFS(vviAns, vi(), 0, graph);\n        return...",
  "content"  : "https://leetcode.com/problems/all-paths-from-source-to-target/\n\nSource\n\n\n    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; allPathsSourceTarget(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; graph) {\n        vvi vviAns;\n        DFS(vviAns, vi(), 0, graph);\n        return vviAns;\n    }\n\n    void DFS(vvi&amp;amp; vviResult, vi viPath, const int cur, vvi&amp;amp; vviGraph) {\n        if (vviGraph.size() == 0) return;\n        if ((cur &amp;lt; 0) || (cur &amp;gt;= vviGraph.size())) return;\n\n        viPath.push_back(cur);\n        if (cur == vviGraph.size()-1) {\n            vviResult.push_back(viPath);\n        }\n\n        for (int next : vviGraph[cur]) {\n            DFS(vviResult, viPath, next, vviGraph);\n        }\n    }\n\n\n\nGitHub\n\n\n  AllPathsSourceTarget\n\n"
} ,
  
  {
    "title"    : "100. Same Tree",
    "category" : "",
    "tags"     : " cpp, easy",
    "url"      : "/algoguru/2021/09/27/same-tree.html",
    "date"     : "September 27, 2021",
    "excerpt"  : "https://leetcode.com/problems/same-tree/\n\nSource\n\n\n        string line;\n        FOR (i, 10) {\n            getline(cin, line);\n            if (line.length() &amp;gt; 2) {\n                break;\n            }\n        }\n\n        vstr vstrSplits = _SplitS...",
  "content"  : "https://leetcode.com/problems/same-tree/\n\nSource\n\n\n        string line;\n        FOR (i, 10) {\n            getline(cin, line);\n            if (line.length() &amp;gt; 2) {\n                break;\n            }\n        }\n\n        vstr vstrSplits = _SplitString(line, &quot;[], \\n&quot;, &quot;=&quot;);\n        vstr vstrTree1;\n        vstr vstrTree2;\n        vstr* pvstrTree = nullptr;\n        bool isNode = false;\n        for (auto str : vstrSplits) {\n            if ((&quot;=&quot; == str) &amp;amp;&amp;amp; (nullptr == pvstrTree)) {\n                pvstrTree = &amp;amp;vstrTree1;\n                isNode = true;\n                continue;\n            }\n\n            if (nullptr != pvstrTree) {\n                if (&quot;q&quot; == str) {\n                    isNode = false;\n                }\n                if (isNode) {\n                    pvstrTree-&amp;gt;push_back(str);\n                }\n                if (&quot;=&quot; == str) {\n                    pvstrTree = &amp;amp;vstrTree2;\n                    isNode = true;\n                }\n            }\n        }\n\n        m_root1 = BFSBuildBST(vstrTree1);\n        m_root2 = BFSBuildBST(vstrTree2);\n\n\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if (nullptr == p &amp;amp;&amp;amp; nullptr == q) return true;\n        if (nullptr == p || nullptr == q) return false;\n        if (p-&amp;gt;val != q-&amp;gt;val) return false;\n\n        const bool leftSame = isSameTree(p-&amp;gt;left, q-&amp;gt;left);\n        const bool rightSame = isSameTree(p-&amp;gt;right, q-&amp;gt;right);\n\n        return (leftSame &amp;amp;&amp;amp; rightSame);\n    }\n\n\n\n\nGitHub\n\n\n  SameTree\n\n"
} ,
  
  {
    "title"    : "338. Counting Bits",
    "category" : "",
    "tags"     : " cpp, easy, radix-conversion",
    "url"      : "/algoguru/2021/09/27/count-bits.html",
    "date"     : "September 27, 2021",
    "excerpt"  : "https://leetcode.com/problems/counting-bits/\n\nSource\n\n\n    vector&amp;lt;int&amp;gt; countBits(int n) {\n        vi viAns;\n        FOR (i, n+1) {\n            const string bin = toBin(i);\n            int sum = 0;\n            FOR (j, bin.length()) {\n        ...",
  "content"  : "https://leetcode.com/problems/counting-bits/\n\nSource\n\n\n    vector&amp;lt;int&amp;gt; countBits(int n) {\n        vi viAns;\n        FOR (i, n+1) {\n            const string bin = toBin(i);\n            int sum = 0;\n            FOR (j, bin.length()) {\n                if (&#39;1&#39; == bin[j]) {\n                    sum++;\n                }\n            }\n            viAns.push_back(sum);\n        }\n        return viAns;\n    }\n\n    string toBin(const int n) {\n        if (n == 1) return &quot;1&quot;;\n        if (n == 0) return &quot;0&quot;;\n        return toBin(n/2) + to_string(n%2);\n    }\n\n\n\nGitHub\n\n\n  CountBits\n\n"
} ,
  
  {
    "title"    : "17. Letter Combinations of a Phone Number",
    "category" : "",
    "tags"     : " cpp, dfs, std-unordered-map, std-unordered-set",
    "url"      : "/algoguru/2021/09/22/letter-combinations-of-a-phone-number.html",
    "date"     : "September 22, 2021",
    "excerpt"  : "https://leetcode.com/problems/letter-combinations-of-a-phone-number/\n\nSource\n\n\n    unordered_map&amp;lt;int, string&amp;gt; lut {\n        {2, &quot;abc&quot;},\n        {3, &quot;def&quot;},\n        {4, &quot;ghi&quot;},\n        {5, &quot;jkl&quot;},\n        {6, &quot;mno&quot;},\n        {7, &quot;pqrs&quot;},\n    ...",
  "content"  : "https://leetcode.com/problems/letter-combinations-of-a-phone-number/\n\nSource\n\n\n    unordered_map&amp;lt;int, string&amp;gt; lut {\n        {2, &quot;abc&quot;},\n        {3, &quot;def&quot;},\n        {4, &quot;ghi&quot;},\n        {5, &quot;jkl&quot;},\n        {6, &quot;mno&quot;},\n        {7, &quot;pqrs&quot;},\n        {8, &quot;tuv&quot;},\n        {9, &quot;wxyz&quot;}\n    };\n\n    vector&amp;lt;string&amp;gt; letterCombinations(string digits) {\n        hashStr hash;\n        DFS(digits, 0, &quot;&quot;, hash);\n        vstr vstrAns;\n        for (auto it=begin(hash); it!=end(hash); ++it) {\n            vstrAns.push_back(*it);\n        }\n        return vstrAns;\n    }\n\n    void DFS(const string&amp;amp; digits, const int idx, const string&amp;amp; letComb, hashStr&amp;amp; hash) {\n        if (digits.length() == 0) {\n            return;\n        }\n        if (idx == digits.length()) {\n            hash.insert(letComb);\n            return;\n        }\n\n        const int num = (digits[idx] - &#39;0&#39;);\n        const string letters = lut[num];\n        FOR (i, letters.length()) {\n            DFS(digits, idx+1, letComb + letters.substr(i, 1), hash);\n        }\n    }\n\n\n\nGitHub\n\n\n  LetterCombinations\n\n\n\n"
} ,
  
  {
    "title"    : "MB2 String Change",
    "category" : "",
    "tags"     : " cpp, string-manipulation, string-substr, string-find, string-replace",
    "url"      : "/algoguru/2021/09/21/mb-2-string-change.html",
    "date"     : "September 21, 2021",
    "excerpt"  : "Source\n\n\n    bool isValid(const string&amp;amp; a) {\n        string subA = a;\n        while (subA.length() &amp;gt; 0) {\n            if (subA[0] == &#39;a&#39;) {\n                subA = subA.substr(1, subA.length()-1);\n            }\n            else if (subA[(sub...",
  "content"  : "Source\n\n\n    bool isValid(const string&amp;amp; a) {\n        string subA = a;\n        while (subA.length() &amp;gt; 0) {\n            if (subA[0] == &#39;a&#39;) {\n                subA = subA.substr(1, subA.length()-1);\n            }\n            else if (subA[(subA.length()-1)] == &#39;a&#39;) {\n                subA = subA.substr(0, subA.length()-1);\n            }\n            else if ((subA[0] == &#39;b&#39;) &amp;amp;&amp;amp; (subA[(subA.length()-1)] == &#39;b&#39;)) {\n                int cnt = 0;\n                while (subA.length() &amp;gt; 0) {\n                    if ((subA[0] != &#39;b&#39;) || (subA[(subA.length()-1)] != &#39;b&#39;)) {\n                        break;\n                    }\n                    subA = subA.substr(1, subA.length()-2);\n                    cnt++;\n                }\n                FOR (i, cnt) {\n                    string tmp = subA;\n                    auto it = tmp.find(&quot;a&quot;);\n                    if (it != string::npos) {\n                        tmp.replace(it, 1, &quot;&quot;);\n                    }\n                    else {\n                        return false;\n                    }\n                }\n            }\n            else {\n                return false;\n            }\n        }\n        return true;\n    }\n\n\n\nGitHub\n\n\n  MB2_StringChange\n\n\n\n"
} ,
  
  {
    "title"    : "1315. Sum of Nodes with Even-Valued Grandparent",
    "category" : "",
    "tags"     : " cpp, simple-implementation, medium, dfs",
    "url"      : "/algoguru/2021/09/13/sum-even-grand-parent.html",
    "date"     : "September 13, 2021",
    "excerpt"  : "https://leetcode.com/problems/sum-of-nodes-with-even-valued-grandparent/\n\nSource\n\n\n    int sumEvenGrandparent(TreeNode* root) {\n\t\tif (nullptr == root) return 0;\n\t\tint sum = 0;\n\t\tif (root-&amp;gt;val % 2 == 0) {\n\t\t\tsum += sumGrands(root);\n\t\t}\n\t\tsum += ...",
  "content"  : "https://leetcode.com/problems/sum-of-nodes-with-even-valued-grandparent/\n\nSource\n\n\n    int sumEvenGrandparent(TreeNode* root) {\n\t\tif (nullptr == root) return 0;\n\t\tint sum = 0;\n\t\tif (root-&amp;gt;val % 2 == 0) {\n\t\t\tsum += sumGrands(root);\n\t\t}\n\t\tsum += sumEvenGrandparent(root-&amp;gt;left);\n\t\tsum += sumEvenGrandparent(root-&amp;gt;right);\n\t\treturn sum;\n    }\n\n\tint sumGrands(TreeNode* root) {\n\t\tif (nullptr == root) return 0;\n\t\tint sum = 0;\n\t\tif (nullptr != root-&amp;gt;left) {\n\t\t\tTreeNode* node = root-&amp;gt;left-&amp;gt;left;\n\t\t\tif (nullptr != node) {\n\t\t\t\tsum += node-&amp;gt;val;\n\t\t\t}\n\t\t\tnode = root-&amp;gt;left-&amp;gt;right;\n\t\t\tif (nullptr != node) {\n\t\t\t\tsum += node-&amp;gt;val;\n\t\t\t}\n\t\t}\n\t\tif (nullptr != root-&amp;gt;right) {\n\t\t\tTreeNode* node = root-&amp;gt;right-&amp;gt;left;\n\t\t\tif (nullptr != node) {\n\t\t\t\tsum += node-&amp;gt;val;\n\t\t\t}\n\t\t\tnode = root-&amp;gt;right-&amp;gt;right;\n\t\t\tif (nullptr != node) {\n\t\t\t\tsum += node-&amp;gt;val;\n\t\t\t}\n\t\t}\n\t\treturn sum;\n\t}\n\n\n\nGitHub\n\n\n  SumEvenGrandParent\n\n"
} ,
  
  {
    "title"    : "1678. Goal Parser Interpretation",
    "category" : "",
    "tags"     : " cpp, easy, string-manipulation, std-unordered-map, string-replace, string-find",
    "url"      : "/algoguru/2021/09/13/interpret-goal.html",
    "date"     : "September 13, 2021",
    "excerpt"  : "https://leetcode.com/problems/goal-parser-interpretation/\n\nSource\n\n\n    string interpret(string command) {\n        unordered_map&amp;lt;string, string&amp;gt; lut {\n            {&quot;()&quot;, &quot;o&quot;},\n            {&quot;(al)&quot;, &quot;al&quot;}\n        };\n        for (auto it=begin(...",
  "content"  : "https://leetcode.com/problems/goal-parser-interpretation/\n\nSource\n\n\n    string interpret(string command) {\n        unordered_map&amp;lt;string, string&amp;gt; lut {\n            {&quot;()&quot;, &quot;o&quot;},\n            {&quot;(al)&quot;, &quot;al&quot;}\n        };\n        for (auto it=begin(lut); it!=end(lut); ++it) {\n            auto itC = command.find(it-&amp;gt;first);\n            while (itC != std::string::npos) {\n                command.replace(itC, it-&amp;gt;first.length(), it-&amp;gt;second);\n                itC = command.find(it-&amp;gt;first);\n            }\n        }\n        return command;\n    }\n\n\n\nGitHub\n\n\n  InterpretGoal\n\n"
} ,
  
  {
    "title"    : "123. Best Time to Buy and Sell Stock III",
    "category" : "",
    "tags"     : " cpp, mathematics",
    "url"      : "/algoguru/2021/09/06/max-profit-3.html",
    "date"     : "September 6, 2021",
    "excerpt"  : "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/\n\nSource\n\n\n    int maxProfit(vector&amp;lt;int&amp;gt;&amp;amp; prices) {\n        const int NUM_TRS = 2;\n        const int MAX = static_cast&amp;lt;int&amp;gt;(1e5);\n        int position[NUM_TRS] = {MA...",
  "content"  : "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/\n\nSource\n\n\n    int maxProfit(vector&amp;lt;int&amp;gt;&amp;amp; prices) {\n        const int NUM_TRS = 2;\n        const int MAX = static_cast&amp;lt;int&amp;gt;(1e5);\n        int position[NUM_TRS] = {MAX, MAX};\n        int profit[NUM_TRS] = {0, 0};\n        FOR (i, prices.size()) {\n            position[0] = min(position[0], prices[i]);\n            profit[0] = max(profit[0], prices[i]-position[0]);   // profit[0] = prices[i] - position[0]\n            position[1] = min(position[1], (-profit[0] + prices[i]));\n            profit[1] = max(profit[1], prices[i]-position[1]);   // profit[1] = prices[i] - (bought[1] - profit[0])\n        }\n        return profit[1];\n    }\n\n\n\nGitHub\n\n\n  MaxProfit3\n\n\n\n"
} ,
  
  {
    "title"    : "122. Best Time to Buy and Sell Stock II",
    "category" : "",
    "tags"     : " cpp, simple-implementation, medium, dynamic-programming",
    "url"      : "/algoguru/2021/09/06/max-profit-2.html",
    "date"     : "September 6, 2021",
    "excerpt"  : "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/\n\nSource\n\n\n    int maxProfit(vector&amp;lt;int&amp;gt;&amp;amp; prices) {\n\t\tint profit = 0;\n\t\tFOR (i, prices.size()-1) {\n\t\t\tconst int p = prices[i+1] - prices[i];\n\t\t\tif (p &amp;gt; 0) {\n\t\t\t\tprofit +...",
  "content"  : "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/\n\nSource\n\n\n    int maxProfit(vector&amp;lt;int&amp;gt;&amp;amp; prices) {\n\t\tint profit = 0;\n\t\tFOR (i, prices.size()-1) {\n\t\t\tconst int p = prices[i+1] - prices[i];\n\t\t\tif (p &amp;gt; 0) {\n\t\t\t\tprofit += p;\n\t\t\t}\n\t\t}\n\t\treturn profit;\n\t}\n\n    int maxProfitIF(vector&amp;lt;int&amp;gt;&amp;amp; prices) {\n\t\tint profit = 0;\n\t\tint ud = -1;\t// start with going down\n\t\tint pos = -1;\n\t\tFOR (i, prices.size()-1) {\n\t\t\tif (prices[i] &amp;lt; prices[i+1]) {\n\t\t\t\tif (ud &amp;lt; 0) {\n\t\t\t\t\t// go up\n\t\t\t\t\tpos = prices[i];\n#ifdef TEST\n\t\t\t\t\tcout &amp;lt;&amp;lt; &quot;pos:&quot; &amp;lt;&amp;lt; pos &amp;lt;&amp;lt; endl;\n#endif\n\t\t\t\t}\n\t\t\t\tud = 1;\n\t\t\t}\n\t\t\telse if (prices[i] &amp;gt; prices[i+1]) {\n\t\t\t\tif (ud &amp;gt; 0) {\n\t\t\t\t\t// go down\n\t\t\t\t\tif (pos &amp;gt;= 0) {\n\t\t\t\t\t\tprofit += (prices[i] - pos);\n#ifdef TEST\n                        cout &amp;lt;&amp;lt; &quot;sell on &quot; &amp;lt;&amp;lt; prices[i] &amp;lt;&amp;lt; &quot; profit:&quot; &amp;lt;&amp;lt; prices[i] - pos &amp;lt;&amp;lt; endl;\n#endif\n\t\t\t\t\t\tpos = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tud = -1;\n\t\t\t}\n\t\t\telse {\n                // ud = 0;  // No need!\n\t\t\t}\n\t\t}\n\n\t\tif (pos == -1) return profit;\n\n\t\tconst int lastP = prices[prices.size()-1] - pos;\n\t\tif (lastP &amp;gt; 0) {\n\t\t\tprofit += lastP;\n\t\t}\n\n\t\treturn profit;\n    }\n\n    int maxProfitDP(vector&amp;lt;int&amp;gt;&amp;amp; prices) {\n\t\tconst size_t n = prices.size();\n        vvi dp(n, vi(n, 0));\n\n\t\tFOR(i, n) {\n\t\t\tif (i &amp;gt; 0) {\n\t\t\t\tif (dp[i][i] &amp;lt; dp[i-1][i-1]) {\n\t\t\t\t\tdp[i][i] = dp[i-1][i-1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tFOR_INC(j, i+1, n) {\n\t\t\t\tconst int p = prices[j] - prices[i];\n\t\t\t\tif (p &amp;gt; 0) {\n\t\t\t\t\tdp[i][j] = p;\n\t\t\t\t\tif (dp[j][j] &amp;lt; p + dp[i][i]) {\n\t\t\t\t\t\tdp[j][j] = p + dp[i][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n#ifdef TEST\n\t\tPrintDP(dp);\n#endif\n\n\t\treturn dp[n-1][n-1];\n    }\n#ifdef TEST\n\tvoid PrintDP(const vvi&amp;amp; dp) {\n\t\tcout &amp;lt;&amp;lt; &quot;\\t&quot;;\n\t\tFOR (j, dp[0].size()) {\n\t\t\tcout &amp;lt;&amp;lt; setw(3) &amp;lt;&amp;lt; j &amp;lt;&amp;lt; &quot;, &quot;;\n\t\t}\n\t\tcout &amp;lt;&amp;lt;endl;\n\t\tFOR (i, dp.size()) {\n\t\t\tcout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &quot;\\t&quot;;\n\t\t\tFOR (j, dp[0].size()) {\n\t\t\t\tcout &amp;lt;&amp;lt; setw(3) &amp;lt;&amp;lt; dp[i][j] &amp;lt;&amp;lt; &quot;, &quot;;\n\t\t\t}\n\t\t\tcout &amp;lt;&amp;lt;endl;\n\t\t}\n\t}\n#endif\n\n\n\nGitHub\n\n\n  MaxProfit2\n\n\n\n"
} ,
  
  {
    "title"    : "LGSW Safe Places",
    "category" : "",
    "tags"     : " cpp, bfs, std-unordered-set, std-queue, flood-fill",
    "url"      : "/algoguru/2021/08/21/lgsw_safe-places.html",
    "date"     : "August 21, 2021",
    "excerpt"  : "\n  Count the number of Safe places\n  Return the maximum number of the counts;\n\n\nSource\n\n\n    void _Solve(){\n\n        int maxSafePls = 0;\n        FOR_DEC(border, 0, m_max+1) {\n            const int numSafePls = CountSafePls(m_grid, border);\n       ...",
  "content"  : "\n  Count the number of Safe places\n  Return the maximum number of the counts;\n\n\nSource\n\n\n    void _Solve(){\n\n        int maxSafePls = 0;\n        FOR_DEC(border, 0, m_max+1) {\n            const int numSafePls = CountSafePls(m_grid, border);\n            if (numSafePls &amp;gt; maxSafePls) {\n                maxSafePls = numSafePls;\n            }\n        }\n        cout &amp;lt;&amp;lt; maxSafePls;\n\n    } // _Solve()\n\n    int CountSafePls(vvi grid, const int border) {\n        vii viiTops = PickStartingPts(grid, border);\n\n        typedef pair&amp;lt;int, ii&amp;gt; i_ii;\n        queue&amp;lt;i_ii&amp;gt; i_iiQ;\n        FOR (i, viiTops.size()) {\n            i_iiQ.push(i_ii(i+1, viiTops[i]));\n        }\n\n        const int maxLoop = INF;\n        for (int i=0; !i_iiQ.empty() &amp;amp;&amp;amp; i&amp;lt;maxLoop; ++i) {\n            const i_ii cnt_pos = i_iiQ.front(); i_iiQ.pop();\n            const int cnt = cnt_pos.first;\n            const ii pos = cnt_pos.second;\n            if (Visit(grid, border, pos, cnt)) {\n                FOR (dir, eDIR_LEN) {\n                    const ii nextPos = ii(  pos.first + DIR[dir][0],\n                                            pos.second + DIR[dir][1]);\n                    if (OOR(nextPos.first, 0, m_N-1)) { continue; }\n                    if (OOR(nextPos.second, 0, m_N-1)) { continue; }\n                    const int val = grid[nextPos.first][nextPos.second];\n                    if (val &amp;lt;= -1*cnt) { continue; }\n                    i_iiQ.push(i_ii(cnt, nextPos));\n                }\n            }\n        }\n\n        unordered_set&amp;lt;int&amp;gt; hashCnt;\n        FOR (r, m_N) {\n            FOR (c, m_N) {\n                const int val = grid[r][c];\n                if (val &amp;lt; 0) {\n                    hashCnt.insert(val);\n                }\n            }\n        }\n\n        return hashCnt.size();\n    }\n\n    bool Visit(vvi&amp;amp; grid, const int border, const ii&amp;amp; pos, const int cnt) {\n        if (OOR(pos.first, 0, m_N)) return false;\n        if (OOR(pos.second, 0, m_N)) return false;\n        const int val = grid[pos.first][pos.second];\n        if (val &amp;gt;= border) {\n            grid[pos.first][pos.second] = -1*cnt;\n            return true;\n        }\n        else if ((val &amp;lt; 0) &amp;amp;&amp;amp; (val &amp;gt; -1*cnt)) {\n            // Update with smaller value (bigger count)\n            grid[pos.first][pos.second] = -1*cnt;\n            return true;\n        }\n        else if (val &amp;lt;= -1*cnt) {\n            return false;\n        }\n        else {}\n    }\n\n    vii PickStartingPts(const vvi&amp;amp; grid, const int border) {\n        vii viiTops;\n        FOR (r, m_N) {\n            FOR (c, m_N) {\n                const int val = grid[r][c];\n                if (val &amp;gt;= border) {\n                    viiTops.push_back(ii(r,c));\n                }\n            }\n        }\n        return viiTops;\n    }\n\n    void PrintGrid(const vvi&amp;amp; grid) {\n        cout &amp;lt;&amp;lt;endl;\n        FOR(i, m_N){\n            FOR(j, m_N){\n                cout &amp;lt;&amp;lt; setw(3) &amp;lt;&amp;lt; grid[i][j] &amp;lt;&amp;lt; &quot; &quot;;\n            }\n            cout &amp;lt;&amp;lt;endl;\n        }\n    }\n\n\n\nGitHub\n\n\n  LGSW_SafePlaces\n\n\n\n"
} ,
  
  {
    "title"    : "LGSW Coupon",
    "category" : "",
    "tags"     : " cpp, simple-implementation, sort",
    "url"      : "/algoguru/2021/08/21/lgsw-coupon.html",
    "date"     : "August 21, 2021",
    "excerpt"  : "\n  N: number of {price : delivery cost}\n  M: initial amount of money\n  1 Coupon: get half price for one of them\n\n\nSource\n\n\n    void _Solve(){\n\n        vii viiP(m_N);\n        FOR (i, m_N) {\n            viiP[i] = ii(-1*m_viiPC[i].first, i);\n        ...",
  "content"  : "\n  N: number of {price : delivery cost}\n  M: initial amount of money\n  1 Coupon: get half price for one of them\n\n\nSource\n\n\n    void _Solve(){\n\n        vii viiP(m_N);\n        FOR (i, m_N) {\n            viiP[i] = ii(-1*m_viiPC[i].first, i);\n        }\n        sort(begin(viiP), end(viiP));\n\n        int maxCnt = 0;\n        int maxRem = 0;\n        FOR(i, m_N)\n        {\n            vii viiPC(m_viiPC);\n            const int idx = viiP[i].second;\n            const int price = viiPC[idx].first;\n            viiPC[idx].first = static_cast&amp;lt;int&amp;gt;(price*0.5);\n\n            Sort(viiPC);\n\n            int rem = m_M;\n            const int cnt = CalCntRem(viiPC, rem);\n\n            if (cnt &amp;gt; maxCnt) {\n                maxCnt = cnt;\n                maxRem = rem;\n            }\n            else if (cnt == maxCnt) {\n                if (rem &amp;gt; maxRem) {\n                    maxRem = rem;\n                }\n            }\n            else {}\n        }\n\n        cout &amp;lt;&amp;lt; maxCnt &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; maxRem;\n    } // _Solve()\n\n\n\nGitHub\n\n\n  LGSW_Coupon\n\n"
} ,
  
  {
    "title"    : "LGSW Compiler",
    "category" : "",
    "tags"     : " cpp, simple-implementation, string-manipulation, string-find_if, string-substr, std-stack",
    "url"      : "/algoguru/2021/08/21/lgsw-compiler.html",
    "date"     : "August 21, 2021",
    "excerpt"  : "\n  Loop compiler &amp;lt;#ABC&amp;gt;\n\n\nSource\n\n\n    string Compile(const string&amp;amp; code) {\n        string str(code);\n\n        typedef pair&amp;lt;char, int&amp;gt; ci;\n        stack&amp;lt;ci&amp;gt; St;\n        FOR (i, str.length()) {\n            const char c = str[i...",
  "content"  : "\n  Loop compiler &amp;lt;#ABC&amp;gt;\n\n\nSource\n\n\n    string Compile(const string&amp;amp; code) {\n        string str(code);\n\n        typedef pair&amp;lt;char, int&amp;gt; ci;\n        stack&amp;lt;ci&amp;gt; St;\n        FOR (i, str.length()) {\n            const char c = str[i];\n            if (c == &#39;&amp;lt;&#39;) {\n                St.push(ci(c, i));\n            }\n            else if (c == &#39;&amp;gt;&#39;) {\n                if (!St.empty()) {\n                    const int beginIdx = St.top().second + 1;\n                    string sub = str.substr(beginIdx, (i - beginIdx));\n                    sub = RollOut(sub);\n                    string prev(str.substr(0, beginIdx-1));\n                    string post(str.substr(i+1, str.length()-(i+1)));\n                    str = prev + sub + post;\n                    St.pop();\n                }\n                else {\n                    return &quot;Error: not paired!&quot;;\n                }\n            }\n            else {}\n        }\n        return str;\n    }\n\n    string RollOut(const string&amp;amp; str) {\n        const auto it = begin(str);\n        const auto itLast = find_if(it, end(str), [](const char c){\n            return isalpha(c);\n        });\n        const int dist = distance(it, itLast);\n        const string strNum = str.substr(0, dist);\n        const int num = stoi(strNum);\n        const int trL = str.length() - dist;\n        const string trStr = str.substr(dist, trL);\n        string result(&quot;&quot;);\n        FOR (i, num) {\n            result += trStr;\n        }\n\n        return result;\n    }\n\n\n\nGitHub\n\n\n  LGSW_Compile\n\n"
} ,
  
  {
    "title"    : "Reversed Look-And-Say",
    "category" : "",
    "tags"     : " cpp, simple-implementation, string-manipulation, std-cin-ignore",
    "url"      : "/algoguru/2021/08/15/reversed-look-and-say.html",
    "date"     : "August 15, 2021",
    "excerpt"  : "https://www.codingame.com/ide/puzzle/reversed-look-and-say\n\nSource\n\n\n    void _Solve(){\n        string s;\n        getline(cin, s); cin.ignore();\n        string strToCheck;\n        while (s.length() &amp;gt; 0) {\n            strToCheck = revLAS(s);\n   ...",
  "content"  : "https://www.codingame.com/ide/puzzle/reversed-look-and-say\n\nSource\n\n\n    void _Solve(){\n        string s;\n        getline(cin, s); cin.ignore();\n        string strToCheck;\n        while (s.length() &amp;gt; 0) {\n            strToCheck = revLAS(s);\n            if (s.compare(strToCheck) == 0) break;\n            if (s.compare(convLAS(strToCheck)) != 0) break;\n            s = strToCheck;\n        }\n        cout &amp;lt;&amp;lt; s;\n    } // _Solve()\n\n    string revLAS(const string&amp;amp; strLAS) {\n        string ret(&quot;&quot;);\n        int numVals = 0;\n        for (auto c : strLAS) {\n            if (0 == numVals) {\n                numVals = c - &#39;0&#39;;\n                continue;\n            }\n            string strVals(numVals, c);\n            ret += strVals;\n            numVals = 0;\n        }\n        return ret;\n    }\n\n    string convLAS(const string&amp;amp; str) {\n        string ret(&quot;&quot;);\n        for (auto it = begin(str); it != end(str);) {\n            auto itLast = find_if_not(next(it), end(str), [it](auto&amp;amp; s){\n                return (s == *it);\n            });\n            ret += to_string(distance(it, itLast));\n            ret += *it;\n            it = itLast;\n        }\n        return ret;\n    }\n\n\n\nGitHub\n\n\n  ReversedLookAndSay\n\n"
} ,
  
  {
    "title"    : "206. Reverse Linked List",
    "category" : "",
    "tags"     : " cpp, linked-list",
    "url"      : "/algoguru/2021/08/15/reverse-linked-list.html",
    "date"     : "August 15, 2021",
    "excerpt"  : "https://leetcode.com/problems/reverse-linked-list/\n\nSource\n\n\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* next = curr-&amp;gt;next;\n          ...",
  "content"  : "https://leetcode.com/problems/reverse-linked-list/\n\nSource\n\n\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* next = curr-&amp;gt;next;\n            curr-&amp;gt;next = prev;\n            prev = curr;\n            curr = next;\n        }\n        return prev;\n    }\n\n\n\nGitHub\n\n\n  ReverseList\n\n"
} ,
  
  {
    "title"    : "92. Reverse Linked List II",
    "category" : "",
    "tags"     : " cpp, simple-implementation, medium, linked-list",
    "url"      : "/algoguru/2021/08/15/reverse-between.html",
    "date"     : "August 15, 2021",
    "excerpt"  : "https://leetcode.com/problems/reverse-linked-list-ii/\n\nSource\n\n\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\n        if (nullptr == head) return nullptr;\n        if (nullptr == head-&amp;gt;next) return head;\n\n        ListNode* ...",
  "content"  : "https://leetcode.com/problems/reverse-linked-list-ii/\n\nSource\n\n\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\n        if (nullptr == head) return nullptr;\n        if (nullptr == head-&amp;gt;next) return head;\n\n        ListNode* itLeftPrev = nullptr;\n        ListNode* itLeft = findNode(head, left, &amp;amp;itLeftPrev);\n        if (nullptr == itLeft) return nullptr;\n\n        ListNode* itRight = findNode(head, right, nullptr);\n        if (nullptr == itRight) return nullptr;\n\n        ListNode* itNewLeft = reverse(itLeft, itRight);\n        W_IFNOT(itRight-&amp;gt;val == itNewLeft-&amp;gt;val);\n        if (nullptr != itLeftPrev) {\n            itLeftPrev-&amp;gt;next = itNewLeft;\n        }\n        else {\n            head = itNewLeft;\n        }\n        return head;\n    }\n\n    ListNode* findNode(ListNode* begin, int pos, ListNode** ppPrev) {\n        if (nullptr == begin) return nullptr;\n        ListNode* curr = begin;\n        ListNode* prev = nullptr;\n        while(curr) {\n            if (--pos == 0) {\n                break;\n            }\n            prev = curr;\n            curr = curr-&amp;gt;next;\n        }\n        if (nullptr != ppPrev) {\n            *ppPrev = prev;\n        }\n        return curr;\n    }\n\n    ListNode* reverse(ListNode* head, ListNode* tail) {\n        if (head == tail) return head;\n        ListNode* curr = head;\n        ListNode* prev = nullptr;\n        while (curr != tail) {\n            ListNode* next = curr-&amp;gt;next;\n            curr-&amp;gt;next = prev;\n            prev = curr;\n            curr = next;\n        }\n        if (nullptr != curr) {\n            head-&amp;gt;next = curr-&amp;gt;next;\n            curr-&amp;gt;next = prev;\n            return curr;\n        }\n        return prev;\n    }\n\n\n\nGitHub\n\n\n  ReverseBetween\n\n"
} ,
  
  {
    "title"    : "Chuck Norris",
    "category" : "",
    "tags"     : " cpp, dfs, string-manipulation, std-unordered-map, back_inserter, radix-conversion",
    "url"      : "/algoguru/2021/08/14/chuck-norris.html",
    "date"     : "August 14, 2021",
    "excerpt"  : "https://www.codingame.com/ide/puzzle/chuck-norris\n\nSource\n\n\n    void _Solve(){\n        string msg;\n        getline(cin, msg);\n\n        vector&amp;lt;bool&amp;gt; bits;\n        for (auto c : msg) {\n            auto binary = toBinStr(c, 7);\n            copy...",
  "content"  : "https://www.codingame.com/ide/puzzle/chuck-norris\n\nSource\n\n\n    void _Solve(){\n        string msg;\n        getline(cin, msg);\n\n        vector&amp;lt;bool&amp;gt; bits;\n        for (auto c : msg) {\n            auto binary = toBinStr(c, 7);\n            copy(begin(binary), end(binary), back_inserter(bits));\n        }\n\n        unordered_map &amp;lt;bool, string&amp;gt; toZeros {\n            {false, &quot;00 &quot;},\n            {true, &quot;0 &quot;}\n        };\n\n        for (auto it = begin(bits); it != end(bits);) {\n            const bool curr = *it;\n            auto itLast = find(next(it), end(bits), !curr);\n            if (it != begin(bits)) cout &amp;lt;&amp;lt; &quot; &quot;;\n            cout &amp;lt;&amp;lt; toZeros[*it] &amp;lt;&amp;lt; string (distance(it, itLast), &#39;0&#39;);\n            it = itLast;\n        }\n    } // _Solve()\n\n    vector&amp;lt;bool&amp;gt; DFS(const int n, const int r) {\n        if (n &amp;lt;= 0) { return {}; }\n        vector&amp;lt;bool&amp;gt; ret = DFS(n/r, r);\n        ret.push_back(n%r);\n        return ret;\n    }\n\n    vector&amp;lt;bool&amp;gt; toBinStr(const int n, const int disp) {\n        vector&amp;lt;bool&amp;gt; bits = DFS(n, 2);\n        int numSp = disp - bits.size();\n        vector&amp;lt;bool&amp;gt; ret(numSp, false);\n        copy(begin(bits), end(bits), back_inserter(ret));\n        return ret;\n    }\n\n\n\nGitHub\n\n\n  ChuckNorris\n\n\n\n"
} ,
  
  {
    "title"    : "938. Range Sum of BST",
    "category" : "",
    "tags"     : " cpp, easy, binary-search-tree",
    "url"      : "/algoguru/2021/08/08/range-sum-bst.html",
    "date"     : "August 8, 2021",
    "excerpt"  : "https://leetcode.com/problems/range-sum-of-bst/\n\nSource\n\n\n    int rangeSumBST(TreeNode* root, int low, int high) {\n        if (nullptr == root) return 0;\n\n        int sum = 0;\n        const int val = root-&amp;gt;val;\n        if ((val &amp;gt;= low) &amp;amp;...",
  "content"  : "https://leetcode.com/problems/range-sum-of-bst/\n\nSource\n\n\n    int rangeSumBST(TreeNode* root, int low, int high) {\n        if (nullptr == root) return 0;\n\n        int sum = 0;\n        const int val = root-&amp;gt;val;\n        if ((val &amp;gt;= low) &amp;amp;&amp;amp; (val &amp;lt;=high)) {\n            sum += val;\n        }\n\n        // if (nullptr != root-&amp;gt;left) {\n        if (val &amp;gt; low) {\n            sum += rangeSumBST(root-&amp;gt;left, low, high);\n        }\n\n        // if (nullptr != root-&amp;gt;right) {\n        if (val &amp;lt; high) {\n            sum += rangeSumBST(root-&amp;gt;right, low, high);\n        }\n\n        return sum;\n    }\n\n// Definition for a binary tree node.\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\n\nTreeNode* BFSBuildBST(const vector&amp;lt;string&amp;gt; vstrVal) {\n    const int n = vstrVal.size();\n    if (n == 0) return nullptr;\n    int cnt = 0;\n    if (&quot;null&quot; == vstrVal[cnt]) {\n        return nullptr;\n    }\n    queue&amp;lt;TreeNode*&amp;gt; qTN;\n    TreeNode* root = new TreeNode(stoi(vstrVal[cnt++]));\n    qTN.emplace(root);\n    while ((!qTN.empty() &amp;amp;&amp;amp; (cnt &amp;lt; n))) {\n        TreeNode* tn = qTN.front(); qTN.pop();\n        string strVal = vstrVal[cnt++];\n        if (&quot;null&quot; != strVal) {\n            tn-&amp;gt;left = new TreeNode(stoi(strVal));\n        }\n        qTN.emplace(tn-&amp;gt;left);\n        if (cnt == n) break;\n\n        strVal = vstrVal[cnt++];\n        if (&quot;null&quot; != strVal) {\n            tn-&amp;gt;right = new TreeNode(stoi(strVal));\n        }\n        qTN.emplace(tn-&amp;gt;right);\n        if (cnt == n) break;\n    }\n\n    return root;\n}\n\n\n\nGitHub\n\n\n  RangeSumBST\n\n"
} ,
  
  {
    "title"    : "617. Merge Two Binary Trees",
    "category" : "",
    "tags"     : " cpp, easy, binary-search-tree",
    "url"      : "/algoguru/2021/08/08/merge-trees.html",
    "date"     : "August 8, 2021",
    "excerpt"  : "https://leetcode.com/problems/merge-two-binary-trees/\n\nSource\n\n\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\n        if ((nullptr == root1) &amp;amp;&amp;amp; (nullptr == root2)) return nullptr;\n\n        if (nullptr == root1) {\n           ...",
  "content"  : "https://leetcode.com/problems/merge-two-binary-trees/\n\nSource\n\n\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\n        if ((nullptr == root1) &amp;amp;&amp;amp; (nullptr == root2)) return nullptr;\n\n        if (nullptr == root1) {\n            return root2;\n        }\n        if (nullptr == root2) {\n            return root1;\n        }\n\n        TreeNode* newRoot = new TreeNode(root1-&amp;gt;val + root2-&amp;gt;val,\n                                         mergeTrees(root1-&amp;gt;left, root2-&amp;gt;left),\n                                         mergeTrees(root1-&amp;gt;right, root2-&amp;gt;right));\n        return newRoot;\n    }\n\n\n\n\n  No more new (dynamic allocations)!\n\n\n\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\n        TreeNode* ans = PickNoneNull(root1, root2);\n        if (nullptr == ans) return nullptr;\n\n        PreorderMerge(ans, root1, root2);\n\n        return ans;\n    }\n\n\n    TreeNode* PickNoneNull(TreeNode* root1, TreeNode* root2) {\n        if ((nullptr == root1) &amp;amp;&amp;amp; (nullptr == root2)) return nullptr;\n\n        if (nullptr == root1) {\n            return root2;\n        }\n        else if (nullptr == root2) {\n            return root1;\n        }\n        else {\n            return root1;\n        }\n    }\n\n    void PreorderMerge(TreeNode* ans, TreeNode* root1, TreeNode* root2) {\n        if (nullptr == ans) return;\n        if ((nullptr == root1) || (nullptr == root2)) return;\n\n        // Visit Root\n        ans-&amp;gt;val = root1-&amp;gt;val + root2-&amp;gt;val;\n\n        // Visit left\n        if (nullptr != ans-&amp;gt;left) {\n            PreorderMerge(ans-&amp;gt;left, root1-&amp;gt;left, root2-&amp;gt;left);\n        }\n        else {\n            // if null, check the other tree!\n            ans-&amp;gt;left = PickNoneNull(root1-&amp;gt;left, root2-&amp;gt;left);\n        }\n\n        // Visit right\n        if (nullptr != ans-&amp;gt;right) {\n            PreorderMerge(ans-&amp;gt;right, root1-&amp;gt;right, root2-&amp;gt;right);\n        }\n        else {\n            // if null, check the other tree!\n            ans-&amp;gt;right = PickNoneNull(root1-&amp;gt;right, root2-&amp;gt;right);\n        }\n    }\n\n\n// Definition for a binary tree node.\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\n\nTreeNode* BFSBuildBST(const vector&amp;lt;string&amp;gt; vstrVal) {\n    const int n = vstrVal.size();\n    if (n == 0) return nullptr;\n    int cnt = 0;\n    if (&quot;null&quot; == vstrVal[cnt]) {\n        return nullptr;\n    }\n    queue&amp;lt;TreeNode*&amp;gt; qTN;\n    TreeNode* root = new TreeNode(stoi(vstrVal[cnt++]));\n    qTN.emplace(root);\n    while ((!qTN.empty() &amp;amp;&amp;amp; (cnt &amp;lt; n))) {\n        TreeNode* tn = qTN.front(); qTN.pop();\n        string strVal = vstrVal[cnt++];\n        if (&quot;null&quot; != strVal) {\n            tn-&amp;gt;left = new TreeNode(stoi(strVal));\n        }\n        qTN.emplace(tn-&amp;gt;left);\n        if (cnt == n) break;\n\n        strVal = vstrVal[cnt++];\n        if (&quot;null&quot; != strVal) {\n            tn-&amp;gt;right = new TreeNode(stoi(strVal));\n        }\n        qTN.emplace(tn-&amp;gt;right);\n        if (cnt == n) break;\n    }\n\n    return root;\n}\n\nvoid BFSPrint(TreeNode* root, int&amp;amp; cnt) {\n    if (cnt == 0) return;\n\n    queue&amp;lt;TreeNode*&amp;gt; qTN;\n    qTN.emplace(root);\n    while ((!qTN.empty()) &amp;amp;&amp;amp; (cnt)) {\n        TreeNode* tn = qTN.front(); qTN.pop();\n        if (nullptr == tn) {\n            cout &amp;lt;&amp;lt; &quot;null, &quot;;\n        }\n        else {\n            cout &amp;lt;&amp;lt; tn-&amp;gt;val &amp;lt;&amp;lt; &quot;, &quot;;\n            cnt--;\n            qTN.emplace(tn-&amp;gt;left);\n            qTN.emplace(tn-&amp;gt;right);\n        }\n    }\n}\n\nvoid PrintBST(TreeNode* root, int cnt) {\n    cout &amp;lt;&amp;lt; &quot;[&quot;;\n    BFSPrint(root, cnt);\n    cout &amp;lt;&amp;lt; &quot;], &quot;;\n}\n\n\n\nGitHub\n\n\n  MergeTrees\n\n"
} ,
  
  {
    "title"    : "894. All Possible Full Binary Trees",
    "category" : "",
    "tags"     : " cpp, dynamic-programming, bfs, std-unordered-map, std-queue, binary-search-tree",
    "url"      : "/algoguru/2021/08/08/all-possible-fbt.html",
    "date"     : "August 8, 2021",
    "excerpt"  : "https://leetcode.com/problems/all-possible-full-binary-trees/\n\nSource\n\n\ntypedef vector&amp;lt;TreeNode*&amp;gt; vTN;\n    vTN m_vTN;\n    vector&amp;lt;TreeNode*&amp;gt; allPossibleFBT(int n) {\n        m_vTN = BST(n);\n        return m_vTN;\n    }\n\n    vector&amp;lt;Tree...",
  "content"  : "https://leetcode.com/problems/all-possible-full-binary-trees/\n\nSource\n\n\ntypedef vector&amp;lt;TreeNode*&amp;gt; vTN;\n    vTN m_vTN;\n    vector&amp;lt;TreeNode*&amp;gt; allPossibleFBT(int n) {\n        m_vTN = BST(n);\n        return m_vTN;\n    }\n\n    vector&amp;lt;TreeNode*&amp;gt; BST(int n) {\n        if (n &amp;lt;= 0) return {};\n        if (n == 1) return {new TreeNode(0)};\n\n        const auto it = hashN.find(n);\n        if (it != end(hashN)) {\n            return it-&amp;gt;second;\n        }\n\n        // n &amp;gt;= 3\n        vTN vTNs;\n        for (int i=1; i&amp;lt;(n-1); i+=2) {          // 3    5   5   7   7   7\n            vTN vTN_left = BST(i);              // 1    1   3   1   3   5\n            vTN vTN_right = BST((n-1)-i);       // 1    3   1   5   3   1\n            for (auto l : vTN_left) {\n                for (auto r : vTN_right) {\n                    TreeNode* root = new TreeNode(0);\n                    root-&amp;gt;left = l;\n                    root-&amp;gt;right = r;\n                    vTNs.push_back(root);\n                }\n            }\n        }\n        hashN.insert(make_pair(n, vTNs));\n        return vTNs;\n    }\n\n\n// Definition for a binary tree node.\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\n\nvoid BFSPrint(TreeNode* root, int&amp;amp; cnt) {\n    if (cnt == 0) return;\n\n    queue&amp;lt;TreeNode*&amp;gt; qTN;\n    qTN.emplace(root);\n    while ((!qTN.empty()) &amp;amp;&amp;amp; (cnt)) {\n        TreeNode* tn = qTN.front(); qTN.pop();\n        if (nullptr == tn) {\n            cout &amp;lt;&amp;lt; &quot;null, &quot;;\n        }\n        else {\n            cout &amp;lt;&amp;lt; tn-&amp;gt;val &amp;lt;&amp;lt; &quot;, &quot;;\n            cnt--;\n            qTN.emplace(tn-&amp;gt;left);\n            qTN.emplace(tn-&amp;gt;right);\n        }\n    }\n}\n\nvoid PrintBST(TreeNode* root, int cnt) {\n    cout &amp;lt;&amp;lt; &quot;[&quot;;\n    BFSPrint(root, cnt);\n    cout &amp;lt;&amp;lt; &quot;], &quot;;\n}\n\n\n\nGitHub\n\n\n  AllPossibleFBT\n\n\n\n"
} ,
  
  {
    "title"    : "Word Conversion",
    "category" : "",
    "tags"     : " cpp, dfs-with-backtracking, string-manipulation, std-unordered-set",
    "url"      : "/algoguru/2021/07/31/word-conversion.html",
    "date"     : "July 31, 2021",
    "excerpt"  : "https://programmers.co.kr/learn/courses/30/lessons/43163\n\nSource\n\n\n    int solution(string begin, string target, vector&amp;lt;string&amp;gt; words) {\n        int answer = 51;\n        \n        hashstr hashWords;\n        int cnt = 0;\n        DFS(answer, ha...",
  "content"  : "https://programmers.co.kr/learn/courses/30/lessons/43163\n\nSource\n\n\n    int solution(string begin, string target, vector&amp;lt;string&amp;gt; words) {\n        int answer = 51;\n        \n        hashstr hashWords;\n        int cnt = 0;\n        DFS(answer, hashWords, cnt, begin, target, words);\n        if (answer == 51) {\n            answer = 0;\n        }\n        \n        return answer;\n    }\n\n    int Diff(const string&amp;amp; str1, const string&amp;amp; str2)\n    {\n        int cnt = 0;\n        for (int i=0; i&amp;lt;str1.length(); ++i) {\n            if ((str1[i] - str2[i]) != 0) {\n                cnt++;\n            }\n        }\n        if (cnt &amp;gt; 1) {\n            return -1;\n        }\n        return cnt;\n    }\n\n    void DFS(int&amp;amp; minCntOut, hashstr&amp;amp; hashWords, const int cnt, const string&amp;amp; curWord, const string&amp;amp; target, const vstr&amp;amp; words)\n    {\n        if (cnt &amp;gt;= minCntOut) {\n            // Stop if the count number is bigger than minimum count\n            return;\n        }\n        \n        if (target.compare(curWord) == 0) {\n            // We found the target string then, stop and store the minimum count\n            minCntOut = cnt;\n            return;\n        }\n        \n        for (int i=0; i&amp;lt;words.size(); ++i) {\n            const string nextWord = words[i];\n            auto it = hashWords.find(nextWord);\n            if (it != end(hashWords)) {\n                // The word has been visited.\n                continue;\n            }\n            if (Diff(curWord, nextWord) &amp;lt;= 0) {\n                // The word is not valid.\n                continue;\n            }\n\n            // Store the valid word in the hash.\n            hashWords.emplace(nextWord);\n\n            // Go to next level\n            DFS(minCntOut, hashWords, cnt+1, nextWord, target, words);\n\n            // Back tracking\n            hashWords.erase(nextWord);\n        }\n    }\n\n\n\nGitHub\n\n\n  WordConversion\n\n"
} ,
  
  {
    "title"    : "21. Merge Two Sorted Lists",
    "category" : "",
    "tags"     : " cpp, easy",
    "url"      : "/algoguru/2021/07/30/merge-two-lists.html",
    "date"     : "July 30, 2021",
    "excerpt"  : "https://leetcode.com/problems/merge-two-sorted-lists/\n\nSource\n\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), nex...",
  "content"  : "https://leetcode.com/problems/merge-two-sorted-lists/\n\nSource\n\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n\n    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\n        ListNode stHead;\n        ListNode* pstCur = &amp;amp;stHead;\n        while ((l1!=nullptr) &amp;amp;&amp;amp; (l2!=nullptr)) {\n            if (l1-&amp;gt;val &amp;lt; l2-&amp;gt;val) {\n                pstCur-&amp;gt;next = l1;\n                l1=l1-&amp;gt;next;\n            }\n            else {\n                pstCur-&amp;gt;next = l2;\n                l2=l2-&amp;gt;next;\n            }\n            pstCur = pstCur-&amp;gt;next;\n        }\n        while (l1!=nullptr) {\n            pstCur-&amp;gt;next = l1;\n            l1=l1-&amp;gt;next;\n            pstCur = pstCur-&amp;gt;next;\n        }\n        while (l2!=nullptr) {\n            pstCur-&amp;gt;next = l2;\n            l2=l2-&amp;gt;next;\n            pstCur = pstCur-&amp;gt;next;\n        }\n        return stHead.next;\n    }\n\n\n\nGitHub\n\n\n  MergeTwoLists\n\n"
} ,
  
  {
    "title"    : "807. Max Increase to Keep City Skyline",
    "category" : "",
    "tags"     : " cpp, simple-implementation, medium",
    "url"      : "/algoguru/2021/07/30/max-increase-keeping-skyline.html",
    "date"     : "July 30, 2021",
    "excerpt"  : "https://leetcode.com/problems/max-increase-to-keep-city-skyline/\n\nSource\n\n\n    int maxIncreaseKeepingSkyline(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; grid) {\n        const int n = grid.size();\n        vi viRowMax(n, 0);\n        vi viColMax(n, 0);\n    ...",
  "content"  : "https://leetcode.com/problems/max-increase-to-keep-city-skyline/\n\nSource\n\n\n    int maxIncreaseKeepingSkyline(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; grid) {\n        const int n = grid.size();\n        vi viRowMax(n, 0);\n        vi viColMax(n, 0);\n        FOR (r, n) {\n            FOR (c, n) {\n                const int val = grid[r][c];\n                if (val &amp;gt; viRowMax[r]) {\n                    viRowMax[r] = val;\n                }\n                if (val &amp;gt; viColMax[c]) {\n                    viColMax[c] = val;\n                }\n            }\n        }\n\n        int sum = 0;\n        FOR (r, n) {\n            FOR (c, n) {\n                const int limit = min(viRowMax[r], viColMax[c]);\n                if (limit &amp;gt; grid[r][c]) {\n                    sum += limit - grid[r][c];\n                }\n            }\n        }\n        return sum;\n    }\n\n\n\nGitHub\n\n\n  MaxIncreaseKeepingSkyline\n\n\n\n"
} ,
  
  {
    "title"    : "1945. Sum of Digits of String After Convert",
    "category" : "",
    "tags"     : " cpp, easy",
    "url"      : "/algoguru/2021/07/30/sum-of-digits-of-string.html",
    "date"     : "July 30, 2021",
    "excerpt"  : "https://leetcode.com/problems/sum-of-digits-of-string-after-convert/\n\nSource\n\n\n    int getLucky(string s, int k) {\n        string strNums;\n        FOR (i, s.length()) {\n            const int n = s[i] - &#39;a&#39; + 1;\n            strNums += to_string(n);...",
  "content"  : "https://leetcode.com/problems/sum-of-digits-of-string-after-convert/\n\nSource\n\n\n    int getLucky(string s, int k) {\n        string strNums;\n        FOR (i, s.length()) {\n            const int n = s[i] - &#39;a&#39; + 1;\n            strNums += to_string(n);\n        }\n        int ans = 0;\n        FOR (i, k) {\n            int sum = 0;\n            FOR (j, strNums.length()) {\n                sum += strNums[j] - &#39;0&#39;;\n            }\n            ans = sum;\n            strNums = to_string(ans);\n        }\n\n        return ans;\n    }\n\n\n\nGitHub\n\n\n  GetLucky\n\n"
} ,
  
  {
    "title"    : "593. Valid Square",
    "category" : "",
    "tags"     : " cpp, simple-implementation, medium, mathematics",
    "url"      : "/algoguru/2021/07/29/valid-square.html",
    "date"     : "July 29, 2021",
    "excerpt"  : "https://leetcode.com/problems/valid-square/\n\nSource\n\n\n    bool validSquare(vector&amp;lt;int&amp;gt;&amp;amp; p1, vector&amp;lt;int&amp;gt;&amp;amp; p2, vector&amp;lt;int&amp;gt;&amp;amp; p3, vector&amp;lt;int&amp;gt;&amp;amp; p4) {\n        vvi vviPts;\n        vviPts.push_back(p1);\n        vviP...",
  "content"  : "https://leetcode.com/problems/valid-square/\n\nSource\n\n\n    bool validSquare(vector&amp;lt;int&amp;gt;&amp;amp; p1, vector&amp;lt;int&amp;gt;&amp;amp; p2, vector&amp;lt;int&amp;gt;&amp;amp; p3, vector&amp;lt;int&amp;gt;&amp;amp; p4) {\n        vvi vviPts;\n        vviPts.push_back(p1);\n        vviPts.push_back(p2);\n        vviPts.push_back(p3);\n        vviPts.push_back(p4);\n        int maxLen = 1;\n        maxLen = calMaxDistSq(vviPts, maxLen);\n\n        vvi vviEndPts = getEndPts(vviPts, maxLen);\n\n        if (vviEndPts.size() &amp;lt; 4) {\n            return false;\n        }\n\n        const int prod = product(vviEndPts);\n        if (prod == 0) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n\n    int product(const vvi&amp;amp; vviEndPts) {\n        vi viPtA, viPtB;\n\n        viPtA.push_back(vviEndPts[0][0] - vviEndPts[1][0]);\n        viPtA.push_back(vviEndPts[0][1] - vviEndPts[1][1]);\n\n        viPtB.push_back(vviEndPts[2][0] - vviEndPts[3][0]);\n        viPtB.push_back(vviEndPts[2][1] - vviEndPts[3][1]);\n\n        return viPtA[0]*viPtB[0] + viPtA[1]*viPtB[1];\n    }\n\n    int calMaxDistSq(const vvi&amp;amp; vviPts, const int initMaxLen) {\n        int maxLen = initMaxLen;\n        for (int i=0; i&amp;lt;3; ++i) {\n            const vi pt1 = vviPts[i];\n            for (int j=i; j&amp;lt;4; ++j) {\n                const vi pt2 = vviPts[j];\n                const int len = distSq(pt1, pt2);\n                if (len &amp;gt; maxLen) {\n                    maxLen = len;\n                }\n            }\n        }\n        return maxLen;\n    }\n\n    int distSq(vi pt1, vi pt2) {\n        const int deltaX = (pt1[0]-pt2[0]);\n        const int deltaY = (pt1[1]-pt2[1]);\n        const int len = deltaX*deltaX + deltaY*deltaY;\n        return len;\n    }\n\n    vvi getEndPts(const vvi&amp;amp; vviPts, const int maxDistSq) {\n        vvi vviEndPts;\n        for (int i=0; i&amp;lt;3; ++i) {\n            const vi pt1 = vviPts[i];\n            for (int j=i; j&amp;lt;4; ++j) {\n                const vi pt2 = vviPts[j];\n                const int len = distSq(pt1, pt2);\n                if (len &amp;gt;= maxDistSq) {\n                    vviEndPts.push_back(pt1);\n                    vviEndPts.push_back(pt2);\n                }\n            }\n        }\n        return vviEndPts;\n    }\n\n\n\nGitHub\n\n\n  ValidSquare\n\n\n\n"
} ,
  
  {
    "title"    : "78. Subsets",
    "category" : "",
    "tags"     : " cpp, dfs-with-backtracking",
    "url"      : "/algoguru/2021/07/29/subsets.html",
    "date"     : "July 29, 2021",
    "excerpt"  : "https://leetcode.com/problems/subsets/\n\nSource\n\n\n    void DFS(vvi&amp;amp; vviSubsets, vi viSubset, const vi&amp;amp; nums, const int idx) {\n        vviSubsets.push_back(viSubset);\n        for (int i=idx; i&amp;lt;nums.size(); ++i) {\n            viSubset.push...",
  "content"  : "https://leetcode.com/problems/subsets/\n\nSource\n\n\n    void DFS(vvi&amp;amp; vviSubsets, vi viSubset, const vi&amp;amp; nums, const int idx) {\n        vviSubsets.push_back(viSubset);\n        for (int i=idx; i&amp;lt;nums.size(); ++i) {\n            viSubset.push_back(nums[i]);\n\n            DFS(vviSubsets, viSubset, nums, i+1);\n\n            viSubset.pop_back();\n        }\n    }\n\n\n\nGitHub\n\n\n  Subsets\n\n\n\n"
} ,
  
  {
    "title"    : "1488. Avoid Flood in The City",
    "category" : "",
    "tags"     : " cpp, dfs-with-backtracking, std-unordered-map, std-set, binary-search",
    "url"      : "/algoguru/2021/07/25/avoid-flood.html",
    "date"     : "July 25, 2021",
    "excerpt"  : "https://leetcode.com/problems/avoid-flood-in-the-city/\n\nSource\n\n\n    vector&amp;lt;int&amp;gt; avoidFlood(vector&amp;lt;int&amp;gt;&amp;amp; rains) {\n        const int numDays = rains.size();\n        vi viAns(numDays);\n        unordered_map&amp;lt;int, int&amp;gt; hashLake_R...",
  "content"  : "https://leetcode.com/problems/avoid-flood-in-the-city/\n\nSource\n\n\n    vector&amp;lt;int&amp;gt; avoidFlood(vector&amp;lt;int&amp;gt;&amp;amp; rains) {\n        const int numDays = rains.size();\n        vi viAns(numDays);\n        unordered_map&amp;lt;int, int&amp;gt; hashLake_RainDay;\n        set&amp;lt;int&amp;gt; setDryDays;\n        FOR (day, numDays) {\n            if (rains[day] == 0) {\n                viAns[day] = 1; // default value\n                setDryDays.emplace(day);\n                continue;\n            }\n\n            viAns[day] = -1;\n            const int fullOfWaterLake = rains[day];\n            auto itLake_RainDay = hashLake_RainDay.find(fullOfWaterLake);\n            if (end(hashLake_RainDay) == itLake_RainDay) {  // not found\n                // first rain\n                hashLake_RainDay[fullOfWaterLake] = day;\n                continue;\n            }\n\n            // second rain\n            if (setDryDays.empty()) {\n                // inevitable flood\n                return vi();\n            }\n\n            const int prevRainDay = itLake_RainDay-&amp;gt;second;\n            int dryDay = -1;\n            auto itDryDay=begin(setDryDays);\n#ifdef BINARY_SEARCH\n            if (*itDryDay &amp;gt; prevRainDay) {\n                // pick the first dry day\n                dryDay = *itDryDay;\n            }\n            else {\n                const int numDryDays = setDryDays.size();\n                const int MAX_L = log2(numDryDays)+3;\n                int hi = numDryDays-1;\n                int lo = 0;\n                for (int i=0; (hi&amp;gt;=lo) &amp;amp;&amp;amp; i&amp;lt;MAX_L; ++i) {\n                    const int mid = (hi+lo) &amp;gt;&amp;gt; 1;\n                    // auto midVal = getNthElem(setDryDays, mid);\n                    auto itMid = next(begin(setDryDays), mid);\n                    if (*itMid &amp;gt;= prevRainDay) {\n                        // dryDay = midVal.first;\n                        dryDay = *itMid; itDryDay = itMid;\n                        if (hi == mid) hi = mid-1;\n                        else hi = mid;\n                    }\n                    else {\n                        if (lo == mid) lo = mid+1;\n                        else lo = mid;\n                    }\n                }\n            }\n#else\n            for (; itDryDay!=end(setDryDays); ++itDryDay) {\n                dryDay = *itDryDay;\n                if (dryDay &amp;lt;= prevRainDay) {\n                    // invalid dry day (too early)\n                    continue;\n                }\n                break;\n            }\n            if (end(setDryDays) == itDryDay) {  // not found\n                // inevitable flood\n                return vi();\n            }\n#endif\n            if (dryDay &amp;lt; 0) return vi();\n\n            // consume a day to be used to dry a lake\n            setDryDays.erase(itDryDay);\n            // dry the lake at the valid dry day\n            viAns[dryDay] = fullOfWaterLake;\n            // dry a lake\n            hashLake_RainDay.erase(itLake_RainDay);\n\n            // but, it rains again...\n            hashLake_RainDay[fullOfWaterLake] = day;\n        }\n        return viAns;\n    }\n\n    template &amp;lt;typename T&amp;gt;\n    pair&amp;lt;T, bool&amp;gt; getNthElem(set&amp;lt;T&amp;gt;&amp;amp; searchSet, int n) {\n        pair&amp;lt;T, bool&amp;gt; result;\n        if (searchSet.size() &amp;gt; static_cast&amp;lt;size_t&amp;gt;(n)) {\n            result.first = *(next(begin(searchSet), n));\n            result.second = true;\n        }\n        else {\n            result.second = false;\n        }\n        return result;\n    }\n\n\n\nGitHub\n\n\n  AvoidFlood\n\n\n\n"
} ,
  
  {
    "title"    : "1365. How Many Numbers Are Smaller Than the Current Number",
    "category" : "",
    "tags"     : " cpp, easy, sort, avoid-nested-loop",
    "url"      : "/algoguru/2021/07/08/smaller-numbers-than-current.html",
    "date"     : "July 8, 2021",
    "excerpt"  : "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/\n\nSource\n\n\n    vector&amp;lt;int&amp;gt; smallerNumbersThanCurrent(vector&amp;lt;int&amp;gt;&amp;amp; nums) {\n        const size_t numNums = nums.size();\n        vii viiNumIdx(numNums)...",
  "content"  : "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/\n\nSource\n\n\n    vector&amp;lt;int&amp;gt; smallerNumbersThanCurrent(vector&amp;lt;int&amp;gt;&amp;amp; nums) {\n        const size_t numNums = nums.size();\n        vii viiNumIdx(numNums);\n        FOR (j, numNums) {\n            viiNumIdx[j] = ii(nums[j], j);\n        }\n\n        sort(begin(viiNumIdx), end(viiNumIdx));\n\n        vi viAns(numNums);\n        int prev = -1;\n        int numEquals = 0;\n        FOR (j, numNums) {\n            const int num = viiNumIdx[j].first;\n            if (prev == num) {\n                numEquals++;\n            }\n            else {\n                numEquals = 0;\n            }\n            viAns[viiNumIdx[j].second] = j - numEquals;\n            prev = num;\n        }\n        return viAns;\n    }\n\n\n\nGitHub\n\n\n  SmallerNumbersThanCurrent\n\n\n\n"
} ,
  
  {
    "title"    : "49. Group Anagrams",
    "category" : "",
    "tags"     : " cpp, sort, std-unordered-map",
    "url"      : "/algoguru/2021/07/08/group-anagrams.html",
    "date"     : "July 8, 2021",
    "excerpt"  : "https://leetcode.com/problems/group-anagrams/\n\nSource\n\n\n    vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; groupAnagrams(vector&amp;lt;string&amp;gt;&amp;amp; strs)\n        unordered_map&amp;lt;string, vstr&amp;gt; umapKeyAnas;\n\n        for (int i=0; i&amp;lt;strs.size(); ++i) {\n   ...",
  "content"  : "https://leetcode.com/problems/group-anagrams/\n\nSource\n\n\n    vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; groupAnagrams(vector&amp;lt;string&amp;gt;&amp;amp; strs)\n        unordered_map&amp;lt;string, vstr&amp;gt; umapKeyAnas;\n\n        for (int i=0; i&amp;lt;strs.size(); ++i) {\n            /*/\n            string strKey = strs[i];\n            sort(begin(strKey), end(strKey));\n            /*/\n            map&amp;lt;char, int&amp;gt; code;\n            for (auto c : strs[i]) {\n                code[c]++;\n            }\n            string strKey;\n            for (auto it=begin(code); it!=end(code); ++it) {\n                strKey.push_back(it-&amp;gt;first);\n                strKey.push_back((&#39;0&#39;+it-&amp;gt;second));\n            }\n            //*/\n\n            if (umapKeyAnas.find(strKey) == end(umapKeyAnas)) {\n                vstr vstrAnas;\n                vstrAnas.push_back(strs[i]);\n                umapKeyAnas.emplace(strKey, vstrAnas);\n            }\n            else {\n                umapKeyAnas[strKey].push_back(strs[i]);\n            }\n        }\n\n        vvstr vvstrAns(umapKeyAnas.size());\n        int cnt = 0;\n        for (auto it = begin(umapKeyAnas); it!=end(umapKeyAnas); ++it) {\n            for (string strVal : it-&amp;gt;second) {\n                vvstrAns[cnt].push_back(strVal);\n            }\n            cnt++;\n        }\n        return vvstrAns;\n    }\n\n\n\nGitHub\n\n\n  GroupAnagrams\n\n\n\n\n"
} ,
  
  {
    "title"    : "ASCII Art",
    "category" : "",
    "tags"     : " cpp, simple-implementation, iomanip-setw, mathematics, string-substr, std-cin-ignore",
    "url"      : "/algoguru/2021/07/08/ascii-art.html",
    "date"     : "July 8, 2021",
    "excerpt"  : "https://www.codingame.com/ide/puzzle/ascii-art\n\nSource\n\n\n        vstr vstrWholeLines;\n        for (int i = 0; i &amp;lt; H; i++) {\n            string ROW;\n            getline(cin, ROW);\n            vstrWholeLines.push_back(ROW);\n        }\n\n        con...",
  "content"  : "https://www.codingame.com/ide/puzzle/ascii-art\n\nSource\n\n\n        vstr vstrWholeLines;\n        for (int i = 0; i &amp;lt; H; i++) {\n            string ROW;\n            getline(cin, ROW);\n            vstrWholeLines.push_back(ROW);\n        }\n\n        const int numLetters = ceil(vstrWholeLines.front().length() / L);\n\n        vector&amp;lt;vstr&amp;gt; vvstrLetters(numLetters);\n\n        for (string line : vstrWholeLines) {\n            size_t prev = 0;\n            FOR (i, numLetters) {\n                vvstrLetters[i].push_back(line.substr(prev, L));\n                prev += L;\n            }\n        }\n\n        const int lastIdx = &#39;Z&#39; - &#39;A&#39; + 1;\n        vi viAnsIdx;\n        FOR (i, N) {\n            int diff = &#39;a&#39; - &#39;A&#39;;\n            int idx = T[i]-&#39;A&#39;;\n            if (idx &amp;gt;= diff) idx -= diff;\n            if (idx &amp;gt; (lastIdx) || idx &amp;lt; 0) idx = lastIdx;\n            viAnsIdx.push_back(idx);\n        }\n\n        // Print answer\n        FOR (j, H) {\n            for (int i : viAnsIdx) {\n                cout &amp;lt;&amp;lt; setw(L) &amp;lt;&amp;lt; left &amp;lt;&amp;lt; vvstrLetters[i][j];\n            }\n            cout &amp;lt;&amp;lt; &quot;\\n&quot;;\n        }\n\n\n\nGitHub\n\n\n  ASCIIArt\n\n"
} ,
  
  {
    "title"    : "20. Valid Parentheses",
    "category" : "",
    "tags"     : " cpp, easy",
    "url"      : "/algoguru/2021/07/06/valid-parentheses.html",
    "date"     : "July 6, 2021",
    "excerpt"  : "https://leetcode.com/problems/valid-parentheses/\n\nSource\n\n\n    bool isPair(const char c1, const char c2) {\n        return (c1 == &#39;(&#39; &amp;amp;&amp;amp; c2 == &#39;)&#39;)\n            || (c1 == &#39;{&#39; &amp;amp;&amp;amp; c2 == &#39;}&#39;)\n            || (c1 == &#39;[&#39; &amp;amp;&amp;amp; c2 == &#39;...",
  "content"  : "https://leetcode.com/problems/valid-parentheses/\n\nSource\n\n\n    bool isPair(const char c1, const char c2) {\n        return (c1 == &#39;(&#39; &amp;amp;&amp;amp; c2 == &#39;)&#39;)\n            || (c1 == &#39;{&#39; &amp;amp;&amp;amp; c2 == &#39;}&#39;)\n            || (c1 == &#39;[&#39; &amp;amp;&amp;amp; c2 == &#39;]&#39;);\n    }\n\n    bool isOpening(const char c) {\n        return (c == &#39;(&#39;) || (c == &#39;{&#39;) || (c == &#39;[&#39;);\n    }\n\n    bool isValid(string s) {\n        FOR(i, s.length()) {\n            const char c = s[i];\n            if (isOpening(c)) {\n                m_S.push(s[i]);\n                continue;\n            }\n            if (!m_S.empty()) {\n                if (isPair(m_S.top(), c)) {\n                    m_S.pop();\n                }\n                else return false;\n            }\n            else return false;\n        }\n        if (m_S.empty()) return true;\n        else return false;\n    }\n\n\n\nGitHub\n\n\n  ValidParentheses\n\n\n\n"
} ,
  
  {
    "title"    : "1512. Number of Good Pairs",
    "category" : "",
    "tags"     : " cpp, easy, combination",
    "url"      : "/algoguru/2021/07/06/num-good-pairs.html",
    "date"     : "July 6, 2021",
    "excerpt"  : "https://leetcode.com/problems/number-of-good-pairs/\n\nSource\n\n\n    int numIdenticalPairs(vector&amp;lt;int&amp;gt;&amp;amp; nums) {\n        const int N = nums.size();\n        int cnt = 0;\n        FOR (i, N) {\n            const int selected = nums[i];\n         ...",
  "content"  : "https://leetcode.com/problems/number-of-good-pairs/\n\nSource\n\n\n    int numIdenticalPairs(vector&amp;lt;int&amp;gt;&amp;amp; nums) {\n        const int N = nums.size();\n        int cnt = 0;\n        FOR (i, N) {\n            const int selected = nums[i];\n            FOR_INC (j, i+1, N) {\n                if (selected == nums[j]) {\n                    cnt++;\n                }\n            }\n        }\n        return cnt;\n    }\n\n\n\nGitHub\n\n\n  NumberGoodPairs\n\n\n\n"
} ,
  
  {
    "title"    : "771. Jewels and Stones",
    "category" : "",
    "tags"     : " cpp, easy, string-manipulation, std-find_first_of",
    "url"      : "/algoguru/2021/07/06/jewels-and-stones.html",
    "date"     : "July 6, 2021",
    "excerpt"  : "https://leetcode.com/problems/jewels-and-stones/\n\nSource\n\n\n    int numJewelsInStones(string jewels, string stones) {\n        int cnt = 0;\n        int prev = 0, pos;\n        while ((pos=stones.find_first_of(jewels, prev)) != string::npos) {\n       ...",
  "content"  : "https://leetcode.com/problems/jewels-and-stones/\n\nSource\n\n\n    int numJewelsInStones(string jewels, string stones) {\n        int cnt = 0;\n        int prev = 0, pos;\n        while ((pos=stones.find_first_of(jewels, prev)) != string::npos) {\n            cnt++;\n            prev = pos + 1;\n        }\n        return cnt;\n    }\n\n\n\nGitHub\n\n\n  JewelsStones\n\n\n\n"
} ,
  
  {
    "title"    : "Temperatures",
    "category" : "",
    "tags"     : " cpp, easy",
    "url"      : "/algoguru/2021/06/29/temperatures.html",
    "date"     : "June 29, 2021",
    "excerpt"  : "https://www.codingame.com/ide/puzzle/temperatures\n\nSource\n\n\nint main()\n{\n    int n; // the number of temperatures to analyse\n    cin &amp;gt;&amp;gt; n; cin.ignore();\n    int ans = 0;\n    int clsst2zero = 5527;\n    for (int i = 0; i &amp;lt; n; i++) {\n       ...",
  "content"  : "https://www.codingame.com/ide/puzzle/temperatures\n\nSource\n\n\nint main()\n{\n    int n; // the number of temperatures to analyse\n    cin &amp;gt;&amp;gt; n; cin.ignore();\n    int ans = 0;\n    int clsst2zero = 5527;\n    for (int i = 0; i &amp;lt; n; i++) {\n        int t; // a temperature expressed as an integer ranging from -273 to 5526\n        cin &amp;gt;&amp;gt; t; cin.ignore();\n\n        // Code!\n        int abt = t;\n        if (t &amp;lt; 0) abt *= -1;\n        if ((abt &amp;lt; clsst2zero) || (abt == clsst2zero &amp;amp;&amp;amp; ans &amp;lt; 0)) {\n            clsst2zero = abt;\n            ans = t;\n        }\n\n    }\n\n    // Write an answer using cout. DON&#39;T FORGET THE &quot;&amp;lt;&amp;lt; endl&quot;\n    // To debug: cerr &amp;lt;&amp;lt; &quot;Debug messages...&quot; &amp;lt;&amp;lt; endl;\n\n    cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl;\n}\n\n\n\nGitHub\n\n\n  Temperatures\n\n"
} ,
  
  {
    "title"    : "128. Longest Consecutive Sequence",
    "category" : "",
    "tags"     : " cpp, simple-implementation, medium, sort",
    "url"      : "/algoguru/2021/06/29/Longest-consecutive.html",
    "date"     : "June 29, 2021",
    "excerpt"  : "https://leetcode.com/problems/longest-consecutive-sequence\n\nSource\n\n\n    int longestConsecutive(vector&amp;lt;int&amp;gt;&amp;amp; nums) {\n        sort(begin(nums), end(nums));\n        int prev = -INF;\n        int max = 0;\n        int cnt = 0;\n#ifdef TEST\n   ...",
  "content"  : "https://leetcode.com/problems/longest-consecutive-sequence\n\nSource\n\n\n    int longestConsecutive(vector&amp;lt;int&amp;gt;&amp;amp; nums) {\n        sort(begin(nums), end(nums));\n        int prev = -INF;\n        int max = 0;\n        int cnt = 0;\n#ifdef TEST\n        for (const int num : nums) {cout &amp;lt;&amp;lt; num &amp;lt;&amp;lt;&quot;,&quot;;}\n#endif\n        for (const int num : nums) {\n            P_IFNOT(num &amp;gt;= prev, num);\n            if (num == prev+1) {\n                if (cnt == 0) cnt = 1;\n                cnt++;\n            }\n            else if (num == prev) {\n                // Do nothing\n            }\n            else {\n                if (cnt &amp;gt; max) {\n                    max = cnt;\n                }\n                cnt = 1;\n            }\n            prev = num;\n        }\n        if (cnt &amp;gt; max) {\n            max = cnt;\n        }\n        return max;\n    }\n\n\n\nGitHub\n\n\n  LongestConsecutive\n\n"
} ,
  
  {
    "title"    : "1476. Subrectangle Queries",
    "category" : "",
    "tags"     : " cpp, simple-implementation, medium",
    "url"      : "/algoguru/2021/06/26/subrectagle-queries.html",
    "date"     : "June 26, 2021",
    "excerpt"  : "https://leetcode.com/problems/subrectangle-queries/\n\nSource\n\n\n    class SubrectangleQueries {\n        vvi m_rect;\n    public:\n        SubrectangleQueries(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; rectangle) {\n            m_rect = rectangle;\n        }\n\n...",
  "content"  : "https://leetcode.com/problems/subrectangle-queries/\n\nSource\n\n\n    class SubrectangleQueries {\n        vvi m_rect;\n    public:\n        SubrectangleQueries(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; rectangle) {\n            m_rect = rectangle;\n        }\n\n        void updateSubrectangle(int row1, int col1, int row2, int col2, int newValue) {\n            FOR_INC (row, row1, row2+1) {\n                FOR_INC (col, col1, col2+1) {\n                    m_rect[row][col] = newValue;\n                }\n            }\n        }\n\n        int getValue(int row, int col) {\n            return m_rect[row][col];\n        }\n    };\n\n\n\nGitHub\n\n\n  SubrectangleQueries\n\n"
} ,
  
  {
    "title"    : "1689. Partitioning Into Minimum Number Of Deci-Binary Numbers",
    "category" : "",
    "tags"     : " cpp, simple-implementation, medium",
    "url"      : "/algoguru/2021/06/26/min-partitions.html",
    "date"     : "June 26, 2021",
    "excerpt"  : "https://leetcode.com/problems/partitioning-into-minimum-number-of-deci-binary-numbers/\n\nSource\n\n\n    int minPartitions(string n) {\n        int maxN = 0;\n        FOR (i, n.length()) {\n            const int num = n[i] - &#39;0&#39;;\n            if (num &amp;gt;...",
  "content"  : "https://leetcode.com/problems/partitioning-into-minimum-number-of-deci-binary-numbers/\n\nSource\n\n\n    int minPartitions(string n) {\n        int maxN = 0;\n        FOR (i, n.length()) {\n            const int num = n[i] - &#39;0&#39;;\n            if (num &amp;gt; maxN) {\n                maxN = num;\n            }\n        }\n        return maxN;\n    }\n\n\n\nGitHub\n\n\n  MinPartitions\n\n"
} ,
  
  {
    "title"    : "1672. Richest Customer Wealth",
    "category" : "",
    "tags"     : " cpp, easy",
    "url"      : "/algoguru/2021/06/26/mximum-wealth.html",
    "date"     : "June 26, 2021",
    "excerpt"  : "https://leetcode.com/problems/richest-customer-wealth/\n\nSource\n\n\n    int maximumWealth(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; accounts) {\n        int maxW = 0;\n        for (vi viBanks : accounts) {\n            int sumW = 0;\n            for (int bank...",
  "content"  : "https://leetcode.com/problems/richest-customer-wealth/\n\nSource\n\n\n    int maximumWealth(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; accounts) {\n        int maxW = 0;\n        for (vi viBanks : accounts) {\n            int sumW = 0;\n            for (int bank_bal : viBanks) {\n                sumW += bank_bal;\n            }\n            if (sumW &amp;gt; maxW) {\n                maxW = sumW;\n            }\n        }\n        return maxW;\n    }\n\n\n\nGitHub\n\n\n  MaximumWealth\n\n"
} ,
  
  {
    "title"    : "1431. Kids With the Greatest Number of Candies",
    "category" : "",
    "tags"     : " cpp, easy",
    "url"      : "/algoguru/2021/06/26/kids-with-greatest-num-candies.html",
    "date"     : "June 26, 2021",
    "excerpt"  : "https://leetcode.com/problems/kids-with-the-greatest-number-of-candies/\n\nSource\n\n\n    vector&amp;lt;bool&amp;gt; kidsWithCandies(vector&amp;lt;int&amp;gt;&amp;amp; candies, int extraCandies) {\n        vb vbAns;\n        int max = 0;\n        for (const int kid : candie...",
  "content"  : "https://leetcode.com/problems/kids-with-the-greatest-number-of-candies/\n\nSource\n\n\n    vector&amp;lt;bool&amp;gt; kidsWithCandies(vector&amp;lt;int&amp;gt;&amp;amp; candies, int extraCandies) {\n        vb vbAns;\n        int max = 0;\n        for (const int kid : candies) {\n            if (kid &amp;gt; max) {\n                max = kid;\n            }\n        }\n        for (const int kid : candies) {\n            const int kid_with_ex = kid + extraCandies;\n            vbAns.push_back((kid_with_ex &amp;gt;= max));\n        }\n        return vbAns;\n    }\n\n\n\nGitHub\n\n\n  GreatestNumCandies\n\n"
} ,
  
  {
    "title"    : "1470. Shuffle the Array",
    "category" : "",
    "tags"     : " cpp, easy",
    "url"      : "/algoguru/2021/06/22/shuffle-the-array.html",
    "date"     : "June 22, 2021",
    "excerpt"  : "https://leetcode.com/problems/shuffle-the-array/\n\nSource\n\n\n    vector&amp;lt;int&amp;gt; shuffle(vector&amp;lt;int&amp;gt;&amp;amp; nums, int n) {\n        vi viX, viY;\n        FOR(i, n){\n            viX.push_back(nums[i]);\n            viY.push_back(nums[n+i]);\n      ...",
  "content"  : "https://leetcode.com/problems/shuffle-the-array/\n\nSource\n\n\n    vector&amp;lt;int&amp;gt; shuffle(vector&amp;lt;int&amp;gt;&amp;amp; nums, int n) {\n        vi viX, viY;\n        FOR(i, n){\n            viX.push_back(nums[i]);\n            viY.push_back(nums[n+i]);\n        }\n        vi viAns;\n        int cnt = 0;\n        FOR(i, nums.size()){\n            if (i%2 == 1){\n                viAns.push_back(viY[cnt]);\n                cnt++;\n            }\n            else{\n                viAns.push_back(viX[cnt]);\n            }\n        }\n        return viAns;\n    }\n\n\n\n\n    // Shorter (better) solution\n    vector&amp;lt;int&amp;gt; shuffle(vector&amp;lt;int&amp;gt;&amp;amp; nums, int n) {\n        vi viAns(nums.size());\n        FOR(i, n){\n            viAns[2*i] = (nums[i]);\n            viAns[2*i+1] = (nums[n+i]);\n        }\n        return viAns;\n    }\n\n\n\nGitHub\n\n\n  ShuffleTheArray\n\n"
} ,
  
  {
    "title"    : "1480. Running Sum of 1d Array",
    "category" : "",
    "tags"     : " cpp, easy",
    "url"      : "/algoguru/2021/06/22/running-sum-array.html",
    "date"     : "June 22, 2021",
    "excerpt"  : "https://leetcode.com/problems/running-sum-of-1d-array\n\nSource\n\n\n    vector&amp;lt;int&amp;gt; runningSum(vector&amp;lt;int&amp;gt;&amp;amp; nums) {\n        vector&amp;lt;int&amp;gt; viAns;\n        int sum = 0;\n        for(int i=0; i&amp;lt;nums.size(); ++i){\n            sum += n...",
  "content"  : "https://leetcode.com/problems/running-sum-of-1d-array\n\nSource\n\n\n    vector&amp;lt;int&amp;gt; runningSum(vector&amp;lt;int&amp;gt;&amp;amp; nums) {\n        vector&amp;lt;int&amp;gt; viAns;\n        int sum = 0;\n        for(int i=0; i&amp;lt;nums.size(); ++i){\n            sum += nums[i];\n            viAns.push_back(sum);\n        }\n        return viAns;\n    }\n\n\n\nGitHub\n\n\n  RunningSumArray\n\n"
} ,
  
  {
    "title"    : "1108. Defanging an IP Address",
    "category" : "",
    "tags"     : " cpp, easy, string-manipulation, split-string, string-find_first_of, string-substr",
    "url"      : "/algoguru/2021/06/22/defanging-ip.html",
    "date"     : "June 22, 2021",
    "excerpt"  : "https://leetcode.com/problems/defanging-an-ip-address\n\nSource\n\n\n    string defangIPaddr(string address) {\n        vstr vstrNums;\n        size_t prev = 0;\n        size_t pos = 0;\n        while((pos=address.find_first_of(&quot;\\&quot;.&quot;, prev))!=std::string::...",
  "content"  : "https://leetcode.com/problems/defanging-an-ip-address\n\nSource\n\n\n    string defangIPaddr(string address) {\n        vstr vstrNums;\n        size_t prev = 0;\n        size_t pos = 0;\n        while((pos=address.find_first_of(&quot;\\&quot;.&quot;, prev))!=std::string::npos){\n            int wlen = pos - prev;\n            if (wlen &amp;gt; 0) {\n                vstrNums.push_back(address.substr(prev, wlen));\n            }\n            prev = pos + 1;\n        }\n        int trail = address.length() - prev;\n        if (trail &amp;gt; 0) {\n            vstrNums.push_back(address.substr(prev, trail+1));\n        }\n\n        string strAns;\n        for(string num : vstrNums){\n            strAns += num;\n            strAns += &quot;[.]&quot;;\n        }\n        strAns = strAns.substr(0, (strAns.length()-3));\n        return strAns;\n    }\n\n\n\nGitHub\n\n\n  DefangingIP\n\n"
} ,
  
  {
    "title"    : "Dark Mode",
    "category" : "",
    "tags"     : " Katex, Mermaid, Markdown",
    "url"      : "/algoguru/blogging/2021/04/27/dark-mode.html",
    "date"     : "April 27, 2021",
    "excerpt"  : "More colors with less light. Click the half-moon most top-right button to turn the lights ON/OFF.\nHere is a bit of everything, so you can check how the theme look, have fun! 👌\n\nHeaders\nLevel 2\nLevel 3\nLevel 4\nLevel 5\nLevel 6\n\nHeaders with links\nLe...",
  "content"  : "More colors with less light. Click the half-moon most top-right button to turn the lights ON/OFF.\nHere is a bit of everything, so you can check how the theme look, have fun! 👌\n\nHeaders\nLevel 2\nLevel 3\nLevel 4\nLevel 5\nLevel 6\n\nHeaders with links\nLevel 2\nLevel 3\nLevel 4\nLevel 5\nLevel 6\n\nCode highlight\nMode specific code highlighting themes. Kramdown which is responsible for the color highlighting may be more limited than your IDE.\n\n#!/usr/bin/env python\n&quot;&quot;&quot;\nTest file for syntax\n&quot;&quot;&quot;\n# TODO: Use dark mode\nfrom sys import os\n\ndef foo(bar):\n    try:\n        print(bar)\n    except NameError:\n        print(&quot;Variable bar is not defined&quot;)\n\n\nclass Bar(object):\n    def __init__(self):\n        foo(1)\n        self.octal = &#39;\\04&#39;\n        self.text = &quot;&quot;&quot;Example \\t\\n&quot;&quot;&quot;\n\n    def __exit__(self, *args):\n        print(&#39;exit\\u1111\\xFF&#39;)\n        pass\n\n    @staticmethod\n    def example():\n        assert (1.0 and 2L) or True\n        return { &quot;example&quot;: [(1,), (r&#39;raw&#39;, u&#39;unicode&#39;)]}\n\n\nTables\n\n\n  \n    \n      hex\n      dec\n      oct\n    \n  \n  \n    \n      0\n      0\n      0\n    \n    \n      5\n      5\n      5\n    \n    \n      A\n      10\n      12\n    \n    \n      F\n      16\n      20\n    \n    \n      F5\n      21\n      25\n    \n  \n\n\nKaTeX\n\nSome KaTeX diagrams to check in dark mode:\n\n\\[\\begin{CD}\nA @&amp;gt;a&amp;gt;&amp;gt; B \\\\\n@VbVV @AAcA \\\\\nC @= D\n\\end{CD}\\]\n\n\\[\\utilde{AB}\\]\n\nMermaid\n\n\nflowchart TB\n    c1--&amp;gt;a2\n    subgraph one\n    a1--&amp;gt;a2\n    end\n    subgraph two\n    b1--&amp;gt;b2\n    end\n    subgraph three\n    c1--&amp;gt;c2\n    end\n\n"
} ,
  
  {
    "title"    : "Best Album",
    "category" : "",
    "tags"     : " cpp, string-manipulation, sort, std-unordered-map",
    "url"      : "/algoguru/2021/03/19/best-album.html",
    "date"     : "March 19, 2021",
    "excerpt"  : "https://programmers.co.kr/learn/courses/30/lessons/42579\n\nSource\n\n    vstr vstrGenre;\n    vi viPlays;\n\n  void _Solve(){\n        typedef std::pair&amp;lt;int, vii&amp;gt; i_vii;\n        typedef std::vector&amp;lt;i_vii&amp;gt; vivii;\n        vivii viviiTotVecPlays...",
  "content"  : "https://programmers.co.kr/learn/courses/30/lessons/42579\n\nSource\n\n    vstr vstrGenre;\n    vi viPlays;\n\n  void _Solve(){\n        typedef std::pair&amp;lt;int, vii&amp;gt; i_vii;\n        typedef std::vector&amp;lt;i_vii&amp;gt; vivii;\n        vivii viviiTotVecPlaysId;\n\n        typedef std::unordered_map&amp;lt;string, int&amp;gt; hash_str_i;\n        hash_str_i hash_striGenreIdx;\n\n        int genreCnt = 0;\n        FOR(i, vstrGenre.size()){\n            string genre = vstrGenre[i];\n            int plays = viPlays[i];\n            hash_str_i::iterator it = hash_striGenreIdx.find(genre);\n            if (it == hash_striGenreIdx.end()) {\n                vii viiTotVecPlaysId;\n                viiTotVecPlaysId.push_back(ii(plays, i));\n                viviiTotVecPlaysId.push_back(i_vii(plays, viiTotVecPlaysId));\n                hash_striGenreIdx.insert(str_i(genre, genreCnt++));\n            }\n            else {\n                // vivii[hash-&amp;gt;int].vii.push_back()\n                viviiTotVecPlaysId[it-&amp;gt;second].second.push_back(ii(plays, i));\n                // vivii[hash-&amp;gt;int].int+=plays\n                viviiTotVecPlaysId[it-&amp;gt;second].first+=plays;\n            }\n        }\n\n        std::sort(viviiTotVecPlaysId.begin(), viviiTotVecPlaysId.end(),\n        [](const i_vii &amp;amp;a, const i_vii &amp;amp;b){\n            return a.first &amp;gt; b.first;\n        });\n        vi viPick;\n        for (auto i_viiTotVecPlaysId : viviiTotVecPlaysId) {\n            auto viiPlaysId = i_viiTotVecPlaysId.second;\n            std::sort(viiPlaysId.begin(), viiPlaysId.end(),\n            [](const ii &amp;amp;a, const ii &amp;amp;b){\n                if (a.first == b.second) {\n                    return a.second &amp;lt; b.second;\n                }\n                return a.first &amp;gt; b.first;\n            });\n            for (int j=0; (j&amp;lt;2) &amp;amp;&amp;amp; (j&amp;lt;viiPlaysId.size()); ++j) {\n                viPick.push_back(viiPlaysId[j].second);\n            }\n        }\n        for (auto id : viPick) {\n            cout &amp;lt;&amp;lt; id &amp;lt;&amp;lt; &quot; &quot;;\n        }\n    } // Solve\n\n\n  void _Solve_arch(){\n        typedef std::pair&amp;lt;int, vii&amp;gt; i_vii;\n        typedef std::vector&amp;lt;i_vii&amp;gt; vivii;\n        vivii viviiTotVecPlaysId;\n\n        typedef std::pair&amp;lt;string, i_vii&amp;gt; str_ivii;\n#if 0   // only key can be compared... the code below is not possible\n        struct cmp {\n            bool operator()(const str_ivii &amp;amp;a, const str_ivii &amp;amp;b) const {\n                return a.second.first &amp;gt; b.second.first;\n            }\n        };\n        typedef std::map&amp;lt;string, i_vii, cmp&amp;gt; hash_str_ivii;\n#else\n        typedef std::unordered_map&amp;lt;string, i_vii&amp;gt; hash_str_ivii;\n#endif\n        hash_str_ivii hash_striviiGenre;\n\n        int genreCnt = 0;\n        FOR(i, vstrGenre.size()){\n            string genre = vstrGenre[i];\n            int plays = viPlays[i];\n            hash_str_ivii::iterator it = hash_striviiGenre.find(genre);\n            if (it == hash_striviiGenre.end()) {\n                vii viiTotVecPlaysId;\n                viiTotVecPlaysId.push_back(ii(plays, i));\n                hash_striviiGenre.insert(str_ivii(genre, i_vii(plays, viiTotVecPlaysId)));\n            }\n            else {\n                // hash-&amp;gt;ivii.vii.push_back()\n                it-&amp;gt;second.second.push_back(ii(plays, i));\n                // hash-&amp;gt;ivii.int\n                it-&amp;gt;second.first+=plays;\n            }\n        }\n\n        hash_str_ivii::iterator it = hash_striviiGenre.begin();\n        for (; it!=hash_striviiGenre.end(); ++it) {\n            viviiTotVecPlaysId.push_back(\n                // hash-&amp;gt;ivii.int, hash-&amp;gt;ivii.vii\n                i_vii(it-&amp;gt;second.first, it-&amp;gt;second.second));\n        }\n\n#if 0 // Impossible to sort a map\n        std::sort(hash_striviiGenre.begin(), hash_striviiGenre.end(),\n        [](const string &amp;amp;a, const string &amp;amp;b){\n            return a.length() &amp;gt; b.length();\n        });\n#else\n        std::sort(viviiTotVecPlaysId.begin(), viviiTotVecPlaysId.end(),\n        [](const i_vii &amp;amp;a, const i_vii &amp;amp;b){\n            return a.first &amp;gt; b.first;\n        });\n#endif\n        vi viPick;\n        for (auto i_viiTotVecPlaysId : viviiTotVecPlaysId) {\n            auto viiPlaysId = i_viiTotVecPlaysId.second;\n            std::sort(viiPlaysId.begin(), viiPlaysId.end(),\n            [](const ii &amp;amp;a, const ii &amp;amp;b){\n                if (a.first == b.second) {\n                    return a.second &amp;lt; b.second;\n                }\n                return a.first &amp;gt; b.first;\n            });\n            for (int j=0; (j&amp;lt;2) &amp;amp;&amp;amp; (j&amp;lt;viiPlaysId.size()); ++j) {\n                viPick.push_back(viiPlaysId[j].second);\n            }\n        }\n        for (auto id : viPick) {\n            cout &amp;lt;&amp;lt; id &amp;lt;&amp;lt; &quot; &quot;;\n        }\n    } // Solve\n\n\nGitHub\n\n\n  BestAlbum\n\n\n\n"
} ,
  
  {
    "title"    : "Cell Compete",
    "category" : "",
    "tags"     : " cpp, simple-implementation",
    "url"      : "/algoguru/2019/12/23/cell-compete.html",
    "date"     : "December 23, 2019",
    "excerpt"  : "AMZ Prob\n\nSource\n\n\n    vector&amp;lt;int&amp;gt; cellCompete(int* states, int days){\n\n         FOR(i, NUM_HOUSES){\n            m_dualStates[0][i] = states[i];\n        }\n\n        FOR(d, days){\n            const int i = d%2;\n            const int ni = (d+1)...",
  "content"  : "AMZ Prob\n\nSource\n\n\n    vector&amp;lt;int&amp;gt; cellCompete(int* states, int days){\n\n         FOR(i, NUM_HOUSES){\n            m_dualStates[0][i] = states[i];\n        }\n\n        FOR(d, days){\n            const int i = d%2;\n            const int ni = (d+1)%2;\n            FOR(h, NUM_HOUSES){\n                if(h == 0){\n                    if(m_dualStates[i][h+1] == 0){\n                        m_dualStates[ni][h] = 0;\n                    }\n                    else{\n                        m_dualStates[ni][h] = 1;\n                    }\n                }\n                else if(h == (NUM_HOUSES-1)){\n                    if(m_dualStates[i][h-1] == 0){\n                        m_dualStates[ni][h] = 0;\n                    }\n                    else{\n                        m_dualStates[ni][h] = 1;\n                    }\n                }\n                else{\n                    if(m_dualStates[i][h-1] == m_dualStates[i][h+1]){\n                        m_dualStates[ni][h] = 0;\n                    }\n                    else{\n                        m_dualStates[ni][h] = 1;\n                    }\n                }\n            }\n        }\n        const int resIdx = days%2;\n        return m_dualStates[resIdx];\n    }\n};\n\n\n\nGitHub\n\n\n  CellCompete\n\n\n\n"
} ,
  
  {
    "title"    : "Tech Stuff example",
    "category" : "",
    "tags"     : " Mermaid, Highlight, Markdown",
    "url"      : "/algoguru/2019/11/02/Tech-stuff-example.html",
    "date"     : "November 2, 2019",
    "excerpt"  : "Let’s demo some code snippet, with some mermaid diagrams.\nBecause if you put some code in your blog, you would at least make it:\n\n  Searchable\n  Good-looking\n\n\nSearch on code\n\nSearch should be working even for complicated escape symbols.\n\nsed -i &#39;...",
  "content"  : "Let’s demo some code snippet, with some mermaid diagrams.\nBecause if you put some code in your blog, you would at least make it:\n\n  Searchable\n  Good-looking\n\n\nSearch on code\n\nSearch should be working even for complicated escape symbols.\n\nsed -i &#39;s/\\&quot;hostname\\&quot;\\:.*$/\\&quot;hostname\\&quot;\\: \\&quot;&#39;$IPADDR&#39;\\&quot;\\,/g&#39; open-falcon/agent/config/cfg.json\n\n\nOr try searching for partial of a command, like this article should be returned when looking for “find grep”\n\nfind /etc -type f -exec cat &#39;{}&#39; \\; | tr -c &#39;.[:digit:]&#39; &#39;\\n&#39; | grep &#39;^[^.][^.]*\\.[^.][^.]*\\.[^.][^.]*\\.[^.][^.]*$&#39;\n\n\nCode highlighting examples\n\nBecause you might put code in your blog post, and you want to make sure it will look good in here. Plus that the search\nfunction will still be working!\n\nXML\n\nExample from W3C\n&amp;lt;part number=&quot;1976&quot;&amp;gt;\n  &amp;lt;name&amp;gt;Windscreen Wiper&amp;lt;/name&amp;gt;\n  &amp;lt;description&amp;gt;The Windscreen wiper\n    automatically removes rain\n    from your windscreen, if it\n    should happen to splash there.\n    It has a rubber &amp;lt;ref part=&quot;1977&quot;&amp;gt;blade&amp;lt;/ref&amp;gt;\n    which can be ordered separately\n    if you need to replace it.\n  &amp;lt;/description&amp;gt;\n&amp;lt;/part&amp;gt;\n\n\nJava\n\njava example\n\nimport java.util.*;\n\n@Example\npublic class Demo {\n  private static final String CONSTANT = &quot;String&quot;;\n  private Object o;\n  /**\n   * Creates a new demo.\n   * @param o The object to demonstrate.\n   */\n  public Demo(Object o) {\n    this.o = o !== null ? o : new Object();\n    String s = CONSTANT + &quot;Other example of text&quot;;\n    int i = 123 - 33 % 11;\n  }\n  public static void main(String[] args) {\n    Demo demo = new Demo();\n    System.out.println(demo.o.toString())\n  }\n}\n\n\nJavascript\n\n/**\n * Does a thing\n */\nfunction helloWorld(param1, param2) {\n    const example = `hello ${param1}`\n    var something = {\n        key: &quot;value&quot;,\n        number: 1\n    };\n\n    // Do something\n    if (2.0 % 2 == something) {\n        console.log(&#39;Hello, world!&#39;);\n    } else {\n        return null;\n    }\n\n    // TODO comment\n}\n\n\nJSON\n\n{\n  &quot;animals&quot;: {\n    &quot;tiger&quot;: {\n      &quot;name&quot;: &quot;tiger&quot;,\n      &quot;images&quot;: [&quot;🐯&quot;, &quot;🐅&quot;, &quot;⻁&quot;]\n    },\n    &quot;turtle&quot;: {\n      &quot;age&quot;: 126,\n      &quot;image&quot;: &quot;🐢&quot;\n    },\n    &quot;unicorn&quot;: {\n      &quot;doesExist&quot;: true,\n      &quot;image&quot;: &quot;🦄&quot;\n    }\n  }\n}\n\n\nPython\n\nimport os\n\n\ndef some_function(param_one=&quot;&quot;, param_two=0):\n    r&#39;&#39;&#39;A docstring&#39;&#39;&#39;\n    if param_one &amp;gt; param_two:  # interesting\n        print(&quot;Greater&quot;)\n    return (param_two - param_one + 1 + 0b10) or None\n\n\nclass SomeClass:\n    &quot;&quot;&quot; dunno what I am doing &quot;&quot;&quot;\n\n    def __init__(self):\n        pass\n\n\nYAML\n\nYou can also render some yaml, like this _config.yml:\n\n\n# Welcome to Jekyll!\n#\n# This config file is meant for settings that affect your whole blog, values\n# which you are expected to set up once and rarely edit after that. If you find\n# yourself editing this file very often, consider using Jekyll&#39;s data files\n# feature for the data you need to update frequently.\n#\n# This file, &quot;_config.yml&quot; is *NOT* reloaded automatically when you use\n# &#39;bundle exec jekyll serve&#39;. If you change this file, please restart the server process.\n\n# Site settings\n# These are used to personalize your new site. If you look in the HTML files,\n# you will see them accessed via Cool Wind on prob_solv, , and so on.\n# You can create any custom variable you would like, and they will be accessible\n# in the templates via .\n\n# SITE CONFIGURATION\nbaseurl: &quot;/Type-on-Strap&quot;\nurl: &quot;https://sylhare.github.io&quot;\n\n# THEME-SPECIFIC CONFIGURATION\ntitle: Type on Strap                                    # site&#39;s title\ndescription: &quot;A website with blog posts and pages&quot;      # used by search engines\navatar: assets/img/triangle.png                         # Empty for no avatar in navbar\nfavicon: assets/favicon.ico                             # Icon displayed in the tab\n\nremote_theme: sylhare/Type-on-Strap                     # If using as a remote_theme in github\n\n\nMermaid\n\nDiagrams with mermaid, make sure it is enabled in the _config.yml.\nHere is a simple example:\n\n&amp;lt;!-- To generate a diagram --&amp;gt;\n&amp;lt;div class=&quot;mermaid&quot;&amp;gt;\nsequenceDiagram\n    Alice-&amp;gt;&amp;gt;John: Hello John, how are you?\n    John--&amp;gt;&amp;gt;Alice: Great!\n&amp;lt;/div&amp;gt;\n\n\nThat will be rendered into this:\n\n\n    \n    \n        \n    \n    \n\n\nYou can also go with more complex features and diagrams from the documentation:\n\n▶ More complex diagram\n\nsequenceDiagram\n    participant Alice\n    participant Bob\n    Alice-&amp;gt;&amp;gt;John: Hello John, how are you?\n    loop Healthcheck\n        John-&amp;gt;&amp;gt;John: Fight against hypochondria\n    end\n    Note right of John: Rational thoughts prevail!\n    John--&amp;gt;&amp;gt;Alice: Great!\n    John-&amp;gt;&amp;gt;Bob: How about you?\n    Bob--&amp;gt;&amp;gt;John: Jolly good!\n\n\n\n"
} ,
  
  {
    "title"    : "Atom Decaying",
    "category" : "",
    "tags"     : " cpp, simple-implementation, sort, unique-and-erase-vector, std-stack, std-priority-queue",
    "url"      : "/algoguru/2019/08/14/atom-decaying.html",
    "date"     : "August 14, 2019",
    "excerpt"  : "https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWXRFInKex8DFAUo\n\nSource\n\n\texplicit CProbSolve(const int N) {\n\t\tm_numAtomsN = N;\n\t\tFOR(i, eDIR_LEN){\n\t\t\tvi viEmpty;\n\t\t\tm_vviAtomIdx.push_back(viEmpty);\n\t\t}\n\t\tFOR(atIdx, m...",
  "content"  : "https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWXRFInKex8DFAUo\n\nSource\n\n\texplicit CProbSolve(const int N) {\n\t\tm_numAtomsN = N;\n\t\tFOR(i, eDIR_LEN){\n\t\t\tvi viEmpty;\n\t\t\tm_vviAtomIdx.push_back(viEmpty);\n\t\t}\n\t\tFOR(atIdx, m_numAtomsN) {\n\t\t\tint x, y, dir, enrg;\n\t\t\tcin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y &amp;gt;&amp;gt; dir &amp;gt;&amp;gt; enrg;\n\t\t\tm_vAtoms.push_back(Atom(x, y, dir, enrg));\n\t\t\tm_vviAtomIdx[dir].push_back(atIdx);\n\t\t}\n\t\t_Solve();\n\t}\n\n\tvoid _Solve() {\n\t\t// Find orthogonal crashes of earlier time than the times of relative atoms\n\t\t_FindOrthoCrash();\n\t\t_FindLinearCrash();\n\n\t\t// Sum up the energy of atoms with the limited time\n\t\tconst int energySum = _SumUpEnergy();\n\t\tcout &amp;lt;&amp;lt; energySum &amp;lt;&amp;lt; &quot;\\n&quot;;\n\t}\n\n\tvoid _FindOrthoCrash()\n\t{\n\t\tfor(int atI : m_vviAtomIdx[eD]) {\n\t\t\tfor(int atJ : m_vviAtomIdx[eR]) {\n\t\t\t\tconst Atom_t &amp;amp;at1 = m_vAtoms[atI];\n\t\t\t\tconst Atom_t &amp;amp;at2 = m_vAtoms[atJ];\n\t\t\t\tconst int xVector = at1.x - at2.x;\n\t\t\t\tconst int yVector = at1.y - at2.y;\n\t\t\t\tif (xVector == yVector) {\n\t\t\t\t\tconst int dbldTime = 2 * xVector;\n\t\t\t\t\tm_vCrashes.push_back(Crash(dbldTime, ii(atI, atJ)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int atI : m_vviAtomIdx[eL]) {\n\t\t\tfor(int atJ : m_vviAtomIdx[eU]) {\n\t\t\t\tconst Atom_t &amp;amp;at1 = m_vAtoms[atI];\n\t\t\t\tconst Atom_t &amp;amp;at2 = m_vAtoms[atJ];\n\t\t\t\tconst int xVector = at1.x - at2.x;\n\t\t\t\tconst int yVector = at1.y - at2.y;\n\t\t\t\tif (xVector == yVector) {\n\t\t\t\t\tconst int dbldTime = 2 * xVector;\n\t\t\t\t\tm_vCrashes.push_back(Crash(dbldTime, ii(atI, atJ)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int atI : m_vviAtomIdx[eD]) {\n\t\t\tfor(int atJ : m_vviAtomIdx[eL]) {\n\t\t\t\tconst Atom_t &amp;amp;at1 = m_vAtoms[atI];\n\t\t\t\tconst Atom_t &amp;amp;at2 = m_vAtoms[atJ];\n\t\t\t\tconst int xVector = at2.x - at1.x;\n\t\t\t\tconst int yVector = at1.y - at2.y;\n\t\t\t\tif (xVector == yVector) {\n\t\t\t\t\tconst int dbldTime = 2 * xVector;\n\t\t\t\t\tm_vCrashes.push_back(Crash(dbldTime, ii(atI, atJ)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int atI : m_vviAtomIdx[eR]) {\n\t\t\tfor(int atJ : m_vviAtomIdx[eU]) {\n\t\t\t\tconst Atom_t &amp;amp;at1 = m_vAtoms[atI];\n\t\t\t\tconst Atom_t &amp;amp;at2 = m_vAtoms[atJ];\n\t\t\t\tconst int xVector = at2.x - at1.x;\n\t\t\t\tconst int yVector = at1.y - at2.y;\n\t\t\t\tif (xVector == yVector) {\n\t\t\t\t\tconst int dbldTime = 2 * xVector;\n\t\t\t\t\tm_vCrashes.push_back(Crash(dbldTime, ii(atI, atJ)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t}\n\n\tvoid _FindLinearCrash()\n\t{\n\t\tfor(int atI : m_vviAtomIdx[eD]) {\n\t\t\tfor(int atJ : m_vviAtomIdx[eU]) {\n\t\t\t\tconst Atom_t &amp;amp;at1 = m_vAtoms[atI];\n\t\t\t\tconst Atom_t &amp;amp;at2 = m_vAtoms[atJ];\n\t\t\t\tconst int xVector = at1.x - at2.x;\n\t\t\t\tif (xVector != 0) continue;\n\n\t\t\t\tconst int yVector = at1.y - at2.y;\n\t\t\t\tif (yVector &amp;gt; 0) {\n\t\t\t\t\tconst int dbldTime = yVector;\n\t\t\t\t\tm_vCrashes.push_back(Crash(dbldTime, ii(atI, atJ)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int atI : m_vviAtomIdx[eL]) {\n\t\t\tfor(int atJ : m_vviAtomIdx[eR]) {\n\t\t\t\tconst Atom_t &amp;amp;at1 = m_vAtoms[atI];\n\t\t\t\tconst Atom_t &amp;amp;at2 = m_vAtoms[atJ];\n\t\t\t\tconst int yVector = at1.y - at2.y;\n\t\t\t\tif (yVector != 0) continue;\n\n\t\t\t\tconst int xVector = at1.x - at2.x;\n\t\t\t\tif (xVector &amp;gt; 0) {\n\t\t\t\t\tconst int dbldTime = xVector;\n\t\t\t\t\tm_vCrashes.push_back(Crash(dbldTime, ii(atI, atJ)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint _SumUpEnergy() {\n\t\tint enrgSum = 0;\n\t\tsort(m_vCrashes.begin(), m_vCrashes.end());\n\t\tm_vCrashes.erase(unique(m_vCrashes.begin(), m_vCrashes.end()), m_vCrashes.end());\n\t\tconst int numCrashes = (int)m_vCrashes.size();\n\t\tFOR(crIdx, numCrashes) {\n\t\t\tconst Crash dbldTime_at1at2 = m_vCrashes[crIdx];\n\t\t\tAtom_t &amp;amp;atm1 = m_vAtoms[dbldTime_at1at2.second.first];\n\t\t\tAtom_t &amp;amp;atm2 = m_vAtoms[dbldTime_at1at2.second.second];\n\t\t\tconst int dbldTime = dbldTime_at1at2.first;\n\t\t\tif ((atm1.enrg &amp;lt; 0) &amp;amp;&amp;amp; (atm1.enrg != -dbldTime)) continue;\n\t\t\tif ((atm2.enrg &amp;lt; 0) &amp;amp;&amp;amp; (atm2.enrg != -dbldTime)) continue;\n\t\t\tif (atm1.enrg &amp;gt; 0) {\n\t\t\t\tenrgSum += atm1.enrg;\n\t\t\t\tatm1.enrg = -dbldTime;\n\t\t\t}\n\t\t\tif (atm2.enrg &amp;gt; 0) {\n\t\t\t\tenrgSum += atm2.enrg;\n\t\t\t\tatm2.enrg = -dbldTime;\n\t\t\t}\n\t\t}\n\t\treturn enrgSum;\n\t}\n\n#ifdef PQII\n\tvoid _FindLinearCrash(pqii &amp;amp; pqiiSortedList)\n\t{\n\t\tstack&amp;lt;ii&amp;gt; atmS;\n\t\twhile (!pqiiSortedList.empty()) {\n\t\t\tconst ii XorY_atIdx = pqiiSortedList.top(); pqiiSortedList.pop();\n\t\t\tconst Atom_t atm = m_vAtoms[XorY_atIdx.second];\n\t\t\tif (!atmS.empty()) {\n\t\t\t\tconst ii prev_XorY_atIdx = atmS.top();\n\t\t\t\t// filter out duplicate atom index\n\t\t\t\tif (XorY_atIdx.second == prev_XorY_atIdx.second) continue;\n\t\t\t\tconst Atom_t prev_atm = m_vAtoms[prev_XorY_atIdx.second];\n\t\t\t\tconst int dbldTime = prev_XorY_atIdx.first - XorY_atIdx.first;\n\t\t\t\tif ((prev_atm.dir == eD) || (prev_atm.dir == eL)) {\n\t\t\t\t\tif ((atm.dir == eU) || (atm.dir == eR)) {\n\t\t\t\t\t\tconst int smallerIdx = min(XorY_atIdx.second, prev_XorY_atIdx.second);\n\t\t\t\t\t\tconst int biggerIdx = max(XorY_atIdx.second, prev_XorY_atIdx.second);\n\t\t\t\t\t\tm_vCrashes.push_back(Crash(dbldTime, ii(smallerIdx, biggerIdx)));\n\t\t\t\t\t\tatmS.pop();\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tatmS.push(XorY_atIdx);\n\t\t}\n\t}\n#endif // PQII\n\n\nGitHub\n\n\n  AtomDecaying\n\n\n\n"
} ,
  
  {
    "title"    : "Road Construction",
    "category" : "",
    "tags"     : " cpp, dijkstra, std-priority-queue",
    "url"      : "/algoguru/2019/07/18/RoadConstruction.html",
    "date"     : "July 18, 2019",
    "excerpt"  : "https://codepro.lge.com/exam/18/국내-기출-연습문제/quiz/36\n\nSource\n\n\texplicit CProbSolve(const int N) {\n\t\tm_mapSizeN = N;\n\t\tm_minCost = INF;\n\t\tFOR(row, m_mapSizeN) {\n\t\t\tvii viiRow;\n\t\t\tint cnt = 0;\n\t\t\twhile (cnt &amp;lt; m_mapSizeN) {\n\t\t\t\tconst char cVal = cin...",
  "content"  : "https://codepro.lge.com/exam/18/국내-기출-연습문제/quiz/36\n\nSource\n\n\texplicit CProbSolve(const int N) {\n\t\tm_mapSizeN = N;\n\t\tm_minCost = INF;\n\t\tFOR(row, m_mapSizeN) {\n\t\t\tvii viiRow;\n\t\t\tint cnt = 0;\n\t\t\twhile (cnt &amp;lt; m_mapSizeN) {\n\t\t\t\tconst char cVal = cin.get();\n\t\t\t\tconst int val = cVal - &#39;0&#39;;\n\t\t\t\tif (val &amp;gt;= 0 &amp;amp;&amp;amp; val &amp;lt;= 9) {\n\t\t\t\t\tviiRow.push_back(ii(INF, val));\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tm_map.push_back(viiRow);\n\t\t}\n\t\t_Solve();\n\t}\n\n\tvoid _Dijkstra(const ii start, const ii finish) {\n\t\tm_pqiiPos.push(i_ii(-m_map[start.first][start.second].second, start));\n\t\twhile (!m_pqiiPos.empty()) {\n\t\t\tconst i_ii cost_pos = m_pqiiPos.top(); m_pqiiPos.pop();\n\t\t\tconst int cost = -cost_pos.first;\n\t\t\tconst int row = cost_pos.second.first;\n\t\t\tconst int col = cost_pos.second.second;\n\n\t\t\t// Check if it&#39;s deprecated cost\n\n\t\t\tif (cost &amp;gt; m_map[row][col].first) continue;\n\n\t\t\tFOR(dir, eDIR_LEN) {\n\t\t\t\tconst int nextRow = row + DIR[dir][0];\n\t\t\t\tconst int nextCol = col + DIR[dir][1];\n\t\t\t\tif (OOR(nextRow, 0, m_mapSizeN - 1)) continue;\n\t\t\t\tif (OOR(nextCol, 0, m_mapSizeN - 1)) continue;\n\t\t\t\tconst int nextCost = cost + m_map[nextRow][nextCol].second;\n\n\t\t\t\t// Check if it&#39;s smaller cost\n\n\t\t\t\tif (nextCost &amp;gt;= m_map[nextRow][nextCol].first) continue;\n\n\t\t\t\t// Visit\n\n\t\t\t\tm_map[nextRow][nextCol].first = nextCost;\n#if 1\n\t\t\t\t// Check if it reaches the finish point\n\n\t\t\t\tif ((nextRow == finish.first) &amp;amp;&amp;amp; (nextCol == finish.second)) {\n\t\t\t\t\tm_minCost = nextCost;\n\t\t\t\t\treturn;\n\t\t\t\t}\n#endif // 1\n\t\t\t\t// Add next cell to start from\n\n\t\t\t\tm_pqiiPos.push(i_ii(-nextCost, ii(nextRow, nextCol)));\n\t\t\t}\n\t\t}\n\n\t\tm_minCost = m_map[finish.first][finish.second].first;\n\t}\n\nGitHub\n\n\n  RoadConstruction\n\n\n\n"
} ,
  
  {
    "title"    : "Stem Cell Culture",
    "category" : "",
    "tags"     : " cpp, simple-implementation, bfs-with-generations, std-queue",
    "url"      : "/algoguru/2019/07/18/StemCellCulture.html",
    "date"     : "July 18, 2019",
    "excerpt"  : "https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWXRJ8EKe48DFAUo\n\nSource\n\n\texplicit CProbSolve(const int N, const int M, const int K) {\n\t\t(void)memset(&amp;amp;(g_arMap[0][0]), 0, sizeof(g_arMap));\n\t\tm_initRowsN = N;\n\t...",
  "content"  : "https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWXRJ8EKe48DFAUo\n\nSource\n\n\texplicit CProbSolve(const int N, const int M, const int K) {\n\t\t(void)memset(&amp;amp;(g_arMap[0][0]), 0, sizeof(g_arMap));\n\t\tm_initRowsN = N;\n\t\tm_initColsM = M;\n\t\tm_timeLimitK = K;\n\t\tm_mapMaxRows = INIT_MAP_OFFSET + m_initRowsN + INIT_MAP_OFFSET;\n\t\tm_mapMaxCols = INIT_MAP_OFFSET + m_initColsM + INIT_MAP_OFFSET;\n\t\tm_mapRowRange.first = m_mapMaxRows;\n\t\tm_mapRowRange.second = 0;\n\t\tm_mapColRange.first = m_mapMaxCols;\n\t\tm_mapColRange.second = 0;\n\t\tFOR(row, m_initRowsN) {\n\t\t\tFOR(col, m_initColsM) {\n\t\t\t\tint val = 0;\n\t\t\t\tcin &amp;gt;&amp;gt; val;\n\t\t\t\tif (val &amp;gt; 0) {\n\t\t\t\t\tg_arMap[0][row + INIT_MAP_OFFSET][col + INIT_MAP_OFFSET] = val;\n\t\t\t\t\tg_arMap[1][row + INIT_MAP_OFFSET][col + INIT_MAP_OFFSET] = val;\n\t\t\t\t\t_UpdateRange(row + INIT_MAP_OFFSET, col + INIT_MAP_OFFSET);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t_Solve();\n\t}\n\n\tvoid _BFSwithGenerations() {\n\t\tqueue&amp;lt;i_ii&amp;gt; arqLifePos[2];\n\n\t\tFOR_INC(row, m_mapRowRange.first, m_mapRowRange.second + 1) {\n\t\t\tFOR_INC(col, m_mapColRange.first, m_mapColRange.second + 1) {\n\t\t\t\tconst int val = g_arMap[0][row][col];\n\t\t\t\tif (val &amp;gt; 0) {\n\t\t\t\t\tarqLifePos[0].push(i_ii(2 * val, (ii(row, col))));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// repeat the loop until time limit\n\n\t\tvector&amp;lt;i_ii&amp;gt; vPrevExtendedCells;\n\t\tFOR(gen, m_timeLimitK) {\n\t\t\tconst int i = gen % 2;\n\t\t\tconst int ni = (gen + 1) % 2;\n\n\t\t\tif (!vPrevExtendedCells.empty()) {\n\t\t\t\t// update the map and the queue with previously extended cells\n\n\t\t\t\t_UpdateMapAndQueue(vPrevExtendedCells, arqLifePos[i]);\n\t\t\t}\n\n\t\t\t// visit all the stem cells in the current queue\n\n\t\t\twhile (!arqLifePos[i].empty()) {\n\t\t\t\tconst i_ii life_pos = arqLifePos[i].front(); arqLifePos[i].pop();\n\t\t\t\tconst int row = life_pos.second.first;\n\t\t\t\tconst int col = life_pos.second.second;\n\n\t\t\t\t// getting old\n\n\t\t\t\tconst int life = life_pos.first - 1;\n\t\t\t\tif (life &amp;lt;= 0) {\n\t\t\t\t\t// dies\n\n\t\t\t\t\tg_arMap[0][row][col] = -1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// still alive: push into the next queue\n\n\t\t\t\tarqLifePos[ni].push(i_ii(life, ii(row, col)));\n\t\t\t\tconst int val = g_arMap[0][row][col];\n\t\t\t\tif (life &amp;gt; val) continue;\n\n\t\t\t\t// now active!\n\n\t\t\t\t// for extention, the map is going to be updated in the next loop\n\n\t\t\t\tFOR(dir, eDIR_LEN) {\n\t\t\t\t\tconst int nextRow = row + DIR[dir][0];\n\t\t\t\t\tconst int nextCol = col + DIR[dir][1];\n\t\t\t\t\tP_IFNOT(!OOR(nextRow, 0, m_mapMaxRows - 1), nextRow);\n\t\t\t\t\tP_IFNOT(!OOR(nextCol, 0, m_mapMaxCols - 1), nextCol);\n\t\t\t\t\tif (g_arMap[0][nextRow][nextCol] != 0) continue;\n\n\t\t\t\t\t// previously empty cell\n\n\t\t\t\t\tif (val &amp;gt; g_arMap[1][nextRow][nextCol]) {\n\t\t\t\t\t\tg_arMap[1][nextRow][nextCol] = val;\n\t\t\t\t\t\t_UpdateRange(nextRow, nextCol);\n\n\t\t\t\t\t\t// extention candidates which will get old from the next after the next generation\n\n\t\t\t\t\t\tvPrevExtendedCells.push_back(i_ii((2 * val) + 1, ii(nextRow, nextCol)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t// while (!m_arqLifePos[i].empty())\n\n\n\t\t} // FOR(gen, m_timeLimitK)\n\n\t}\n\n\tvoid _UpdateMapAndQueue(vector&amp;lt;i_ii&amp;gt; &amp;amp;vPrevExtendedCellsOut, queue&amp;lt;i_ii&amp;gt; &amp;amp;qLifePosOut)\n\t{\n\t\twhile (!vPrevExtendedCellsOut.empty()) {\n\t\t\tconst i_ii life_pos = vPrevExtendedCellsOut.back(); vPrevExtendedCellsOut.pop_back();\n\t\t\tconst int row = life_pos.second.first;\n\t\t\tconst int col = life_pos.second.second;\n\t\t\tconst int val = g_arMap[1][row][col];\n\t\t\tif (life_pos.first == (2 * val) + 1) {\n\t\t\t\t// resultant extentions\n\n\t\t\t\tg_arMap[0][row][col] = val;\n\n\t\t\t\t// it start to get old from the next generation\n\n\t\t\t\tqLifePosOut.push(life_pos);\n\t\t\t}\n\t\t}\n\t}\n\nSource with respective queues for each life time\n\n#pragma GCC optimize(&quot;O3&quot;)\n#include &amp;lt;iostream&amp;gt;\n\n#include &amp;lt;algorithm&amp;gt;\n\n#include &amp;lt;memory.h&amp;gt;\n\nusing namespace std;\n \n#define BASE 151\n \nstruct p {\n    int r, x, y;\n};\n \nint map[360][360];\np q[11][2][2001];\t// life time, switching by 2, cell of each life time\n\n \nint main() {\n    ios::sync_with_stdio(false); cin.tie(0);\n    register int t, tc, N, M, K, s, dx[] = { 0,0,1,-1 }, dy[] = { 1,-1,0,0 }, idx[11][2] = { 0, };\n     \n    cin &amp;gt;&amp;gt; t;\n    for (tc = 1; tc &amp;lt;= t; ++tc) {\n        register int i, j, k, l, nx, ny, ans, siz, ni, tt;\n        memset(map, 0, sizeof(map));\n        memset(idx, 0, sizeof(idx));\n        cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; M &amp;gt;&amp;gt; K;\n        ans = 0;\n        for (i = 0; i &amp;lt; N; ++i) for (j = 0; j &amp;lt; M; ++j) {\n            nx = i + BASE; ny = j + BASE;\n            cin &amp;gt;&amp;gt; tt;\n            if (tt)\n                q[tt][0][idx[tt][0]++] = { 2 * tt, nx, ny };\n            map[nx][ny] = tt;\n        }\n        s = 0;\n\t\t// for generations\n\n        for (i = 0; i &amp;lt;= K; ++i) {\n\t\t\t// for each life time\n\n            for (j = 10; j &amp;gt;= 1; --j) {\n                siz = idx[j][i % 2];\n                ni = (i + 1) % 2;\n                idx[j][ni] = 0;\n\n\t\t\t\t// for each cell of each life time\n\n                for (k = 0; k &amp;lt; siz; ++k) {\n                    p &amp;amp;x = q[j][i%2][k];\n                    if (x.r &amp;gt; j) {\n                        if (map[x.x][x.y] &amp;gt; 0) {\n                            ans++;\n                            map[x.x][x.y] *= -1;\n                        }\n                        q[j][ni][idx[j][ni]++] = { x.r - 1,x.x,x.y };\n                    }\n                    else if (x.r == j) {\n                        q[j][ni][idx[j][ni]++] = { x.r - 1,x.x,x.y };\n                        for (l = 0; l &amp;lt; 4; ++l) {\n                            nx = x.x + dx[l];\n                            ny = x.y + dy[l];\n                            if (map[nx][ny]) continue;\n                            map[nx][ny] = j;\n                            q[j][ni][idx[j][ni]++] = { 2 * j,nx,ny };\n                        }\n                    }\n                    else if (j &amp;gt; x.r &amp;amp;&amp;amp; x.r)\n                        q[j][ni][idx[j][ni]++] = { x.r - 1,x.x,x.y };\n                    else\n                        ans--;\n                }\n            }\n        }\n        cout &amp;lt;&amp;lt; &#39;#&#39; &amp;lt;&amp;lt; tc &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; &#39;\\n&#39;;\n    }\n    return 0;\n}\n\nGitHub\n\n\n  StemCellCulture\n\n\n\n"
} ,
  
  {
    "title"    : "Game 2048",
    "category" : "",
    "tags"     : " cpp, simple-implementation, dfs-with-backtracking",
    "url"      : "/algoguru/2019/07/17/Game-Two-Zero-Four-Eight.html",
    "date"     : "July 17, 2019",
    "excerpt"  : "https://www.acmicpc.net/problem/12100\n\nSource\n\n\tvoid _DFS(const vvi &amp;amp;map, const int numMoves, const Dir_e dir) {\n\t\tvvi movedMap(map);\n#if 1\n        _MoveWithQ(dir, movedMap);\n#else\n        _Move(dir, movedMap);\n#endif // 0\n\n\t\tif (numMoves == M...",
  "content"  : "https://www.acmicpc.net/problem/12100\n\nSource\n\n\tvoid _DFS(const vvi &amp;amp;map, const int numMoves, const Dir_e dir) {\n\t\tvvi movedMap(map);\n#if 1\n        _MoveWithQ(dir, movedMap);\n#else\n        _Move(dir, movedMap);\n#endif // 0\n\n\t\tif (numMoves == MAX_MOVES)\n        {\n\t\t\tconst int biggest = GetBiggest(movedMap);\n\t\t\tif (biggest &amp;gt; m_maxVal) {\n\t\t\t\tm_maxVal = biggest;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tFOR(nextDir, eDIR_LEN) {\n\t\t\t_DFS(movedMap, numMoves + 1, (Dir_e)nextDir);\n\t\t}\n\t}\n\n\tint _MoveWithQ(const Dir_e dir, vvi &amp;amp;mapOut) {\n\t\tint numMerges = 0;\n\t\tswitch (dir)\n\t\t{\n\t\tcase eR:\n\t\t\tFOR(row, m_mapSizeN) {\n\t\t\t\tqi qiVals;\n\t\t\t\tFOR_DEC(col, 0, m_mapSizeN) {\n\t\t\t\t\tconst int val = mapOut[row][col];\n\t\t\t\t\tif (val &amp;gt; 0) {\n\t\t\t\t\t\tmapOut[row][col] = 0;\n\t\t\t\t\t\tqiVals.push(val);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tFOR_DEC(col, 0, m_mapSizeN) {\n\t\t\t\t\t_FillCell(row, col,\n\t\t\t\t\t\t\t  mapOut, qiVals, numMerges);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase eD:\n\t\t\tFOR(col, m_mapSizeN) {\n\t\t\t\tqi qiVals;\n\t\t\t\tFOR_DEC(row, 0, m_mapSizeN) {\n\t\t\t\t\tconst int val = mapOut[row][col];\n\t\t\t\t\tif (val &amp;gt; 0) {\n\t\t\t\t\t\tmapOut[row][col] = 0;\n\t\t\t\t\t\tqiVals.push(val);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tFOR_DEC(row, 0, m_mapSizeN) {\n\t\t\t\t\t_FillCell(row, col,\n\t\t\t\t\t\t\t  mapOut, qiVals, numMerges);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase eL:\n\t\t\tFOR(row, m_mapSizeN) {\n\t\t\t\tqi qiVals;\n\t\t\t\tFOR_INC(col, 0, m_mapSizeN) {\n\t\t\t\t\tconst int val = mapOut[row][col];\n\t\t\t\t\tif (val &amp;gt; 0) {\n\t\t\t\t\t\tmapOut[row][col] = 0;\n\t\t\t\t\t\tqiVals.push(val);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tFOR_INC(col, 0, m_mapSizeN) {\n\t\t\t\t\t_FillCell(row, col,\n\t\t\t\t\t\t\t  mapOut, qiVals, numMerges);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase eU:\n\t\t\tFOR(col, m_mapSizeN) {\n\t\t\t\tqi qiVals;\n\t\t\t\tFOR_INC(row, 0, m_mapSizeN) {\n\t\t\t\t\tconst int val = mapOut[row][col];\n\t\t\t\t\tif (val &amp;gt; 0) {\n\t\t\t\t\t\tmapOut[row][col] = 0;\n\t\t\t\t\t\tqiVals.push(val);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tFOR_INC(row, 0, m_mapSizeN) {\n\t\t\t\t\t_FillCell(row, col,\n\t\t\t\t\t\t\t  mapOut, qiVals, numMerges);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tP_IFNOT(dir &amp;lt; eDIR_LEN, dir);\n\t\t\tbreak;\n\t\t}\n\n\t\treturn numMerges;\n\t}\n\n\tvoid _FillCell(const int row, const int col,\n\t\t\t\t   vvi &amp;amp;mapOut, qi &amp;amp;qiValsOut, int &amp;amp;numMergesOut) {\n\t\tint pivotVal = -1;\n\n\t\t// A. visit next\n\n\t\twhile (!qiValsOut.empty()) {\n\t\t\tconst int val = qiValsOut.front();\n\n\t\t\t// C. check to be merged\n\n\t\t\tif (val == pivotVal) {\n\t\t\t\tmapOut[row][col] = pivotVal * 2;\n\t\t\t\tpivotVal = -1;\n\t\t\t\tnumMergesOut++;\n\t\t\t\tqiValsOut.pop();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (pivotVal != -1) {\n\t\t\t\t\tpivotVal = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// D. set pivot\n\n\t\t\tpivotVal = val;\n\t\t\tmapOut[row][col] = pivotVal;\n\t\t\tqiValsOut.pop();\n\t\t}\n\t}\n\n\tint _Move(const Dir_e dir, vvi &amp;amp;mapOut) {\n\t\tint numMerges = 0;\n\t\tswitch (dir)\n\t\t{\n\t\tcase eR:\n\t\t\tFOR(row, m_mapSizeN) {\n\t\t\t\tint pivotVal = 0;\n\t\t\t\tint pivotCol = 0;\n\t\t\t\tint emptyCellCol = 0;\n\t\t\t\tFOR_DEC(col, 0, m_mapSizeN) {\n\t\t\t\t\t// A. visit next\n\n\t\t\t\t\tconst int val = mapOut[row][col];\n\t\t\t\t\tif (val &amp;gt; 0) {\n\t\t\t\t\t\tif (pivotVal != 0) {\n\t\t\t\t\t\t\t// C. check to be merged\n\n\t\t\t\t\t\t\tif (pivotVal == val) {\n\t\t\t\t\t\t\t\tmapOut[row][pivotCol] = pivotVal * 2;\n\t\t\t\t\t\t\t\tpivotVal = 0;\n\t\t\t\t\t\t\t\tmapOut[row][col] = 0;\n\t\t\t\t\t\t\t\tnumMerges++;\n\n\t\t\t\t\t\t\t\t// G. set empty cell\n\n\t\t\t\t\t\t\t\tif (emptyCellCol == 0) {\n\t\t\t\t\t\t\t\t\temptyCellCol = col;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// D. set pivot\n\n\t\t\t\t\t\tpivotVal = val;\n\t\t\t\t\t\tif (emptyCellCol &amp;gt; 0) {\n\t\t\t\t\t\t\tpivotCol = emptyCellCol;\n\n\t\t\t\t\t\t\t// E. move pivot value into empty cell\n\n\t\t\t\t\t\t\tmapOut[row][emptyCellCol] = pivotVal;\n\t\t\t\t\t\t\tmapOut[row][col] = 0;\n\n\t\t\t\t\t\t\t// F. set next empty cell\n\n\t\t\t\t\t\t\tif (emptyCellCol &amp;gt; col) {\n\t\t\t\t\t\t\t\t--emptyCellCol;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tpivotCol = col;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// B. set empty cell\n\n\t\t\t\t\t\tif (emptyCellCol == 0) {\n\t\t\t\t\t\t\temptyCellCol = col;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase eD:\n\t\t\tFOR(col, m_mapSizeN) {\n\t\t\t\tint pivotVal = 0;\n\t\t\t\tint pivotRow = 0;\n\t\t\t\tint emptyCellRow = 0;\n\t\t\t\tFOR_DEC(row, 0, m_mapSizeN) {\n\t\t\t\t\t// A. visit next\n\n\t\t\t\t\tconst int val = mapOut[row][col];\n\t\t\t\t\tif (val &amp;gt; 0) {\n\t\t\t\t\t\tif (pivotVal != 0) {\n\t\t\t\t\t\t\t// C. check to be merged\n\n\t\t\t\t\t\t\tif (pivotVal == val) {\n\t\t\t\t\t\t\t\tmapOut[pivotRow][col] = pivotVal * 2;\n\t\t\t\t\t\t\t\tpivotVal = 0;\n\t\t\t\t\t\t\t\tmapOut[row][col] = 0;\n\t\t\t\t\t\t\t\tnumMerges++;\n\n\t\t\t\t\t\t\t\t// G. set empty cell\n\n\t\t\t\t\t\t\t\tif (emptyCellRow == 0) {\n\t\t\t\t\t\t\t\t\temptyCellRow = row;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// D. set pivot\n\n\t\t\t\t\t\tpivotVal = val;\n\t\t\t\t\t\tif (emptyCellRow &amp;gt; 0) {\n\t\t\t\t\t\t\tpivotRow = emptyCellRow;\n\n\t\t\t\t\t\t\t// E. move pivot value into empty cell\n\n\t\t\t\t\t\t\tmapOut[emptyCellRow][col] = pivotVal;\n\t\t\t\t\t\t\tmapOut[row][col] = 0;\n\n\t\t\t\t\t\t\t// F. set next empty cell\n\n\t\t\t\t\t\t\tif (emptyCellRow &amp;gt; row) {\n\t\t\t\t\t\t\t\t--emptyCellRow;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tpivotRow = row;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// B. set empty cell\n\n\t\t\t\t\t\tif (emptyCellRow == 0) {\n\t\t\t\t\t\t\temptyCellRow = row;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase eL:\n\t\t\tFOR(row, m_mapSizeN) {\n\t\t\t\tint pivotVal = 0;\n\t\t\t\tint pivotCol = 0;\n\t\t\t\tint emptyCellCol = m_mapSizeN;\n\t\t\t\tFOR_INC(col, 0, m_mapSizeN) {\n\t\t\t\t\t// A. visit next\n\n\t\t\t\t\tconst int val = mapOut[row][col];\n\t\t\t\t\tif (val &amp;gt; 0) {\n\t\t\t\t\t\tif (pivotVal != 0) {\n\t\t\t\t\t\t\t// C. check to be merged\n\n\t\t\t\t\t\t\tif (pivotVal == val) {\n\t\t\t\t\t\t\t\tmapOut[row][pivotCol] = pivotVal * 2;\n\t\t\t\t\t\t\t\tpivotVal = 0;\n\t\t\t\t\t\t\t\tmapOut[row][col] = 0;\n\t\t\t\t\t\t\t\tnumMerges++;\n\n\t\t\t\t\t\t\t\t// G. set empty cell\n\n\t\t\t\t\t\t\t\tif (emptyCellCol == m_mapSizeN) {\n\t\t\t\t\t\t\t\t\temptyCellCol = col;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// D. set pivot\n\n\t\t\t\t\t\tpivotVal = val;\n\t\t\t\t\t\tif (emptyCellCol &amp;lt; m_mapSizeN) {\n\t\t\t\t\t\t\tpivotCol = emptyCellCol;\n\n\t\t\t\t\t\t\t// E. move pivot value into empty cell\n\n\t\t\t\t\t\t\tmapOut[row][emptyCellCol] = pivotVal;\n\t\t\t\t\t\t\tmapOut[row][col] = 0;\n\n\t\t\t\t\t\t\t// F. set next empty cell\n\n\t\t\t\t\t\t\tif (emptyCellCol &amp;lt; col) {\n\t\t\t\t\t\t\t\t++emptyCellCol;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tpivotCol = col;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// B. set empty cell\n\n\t\t\t\t\t\tif (emptyCellCol == m_mapSizeN) {\n\t\t\t\t\t\t\temptyCellCol = col;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase eU:\n\t\t\tFOR(col, m_mapSizeN) {\n\t\t\t\tint pivotVal = 0;\n\t\t\t\tint pivotRow = 0;\n\t\t\t\tint emptyCellRow = m_mapSizeN;\n\t\t\t\tFOR_INC(row, 0, m_mapSizeN) {\n\t\t\t\t\t// A. visit next\n\n\t\t\t\t\tconst int val = mapOut[row][col];\n\t\t\t\t\tif (val &amp;gt; 0) {\n\t\t\t\t\t\tif (pivotVal != 0) {\n\t\t\t\t\t\t\t// C. check to be merged\n\n\t\t\t\t\t\t\tif (pivotVal == val) {\n\t\t\t\t\t\t\t\tmapOut[pivotRow][col] = pivotVal * 2;\n\t\t\t\t\t\t\t\tpivotVal = 0;\n\t\t\t\t\t\t\t\tmapOut[row][col] = 0;\n\t\t\t\t\t\t\t\tnumMerges++;\n\n\t\t\t\t\t\t\t\t// G. set empty cell\n\n\t\t\t\t\t\t\t\tif (emptyCellRow == m_mapSizeN) {\n\t\t\t\t\t\t\t\t\temptyCellRow = row;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// D. set pivot\n\n\t\t\t\t\t\tpivotVal = val;\n\t\t\t\t\t\tif (emptyCellRow &amp;lt; m_mapSizeN) {\n\t\t\t\t\t\t\tpivotRow = emptyCellRow;\n\n\t\t\t\t\t\t\t// E. move pivot value into empty cell\n\n\t\t\t\t\t\t\tmapOut[emptyCellRow][col] = pivotVal;\n\t\t\t\t\t\t\tmapOut[row][col] = 0;\n\n\t\t\t\t\t\t\t// F. set next empty cell\n\n\t\t\t\t\t\t\tif (emptyCellRow &amp;lt; row) {\n\t\t\t\t\t\t\t\t++emptyCellRow;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tpivotRow = row;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// B. set empty cell\n\n\t\t\t\t\t\tif (emptyCellRow == m_mapSizeN) {\n\t\t\t\t\t\t\temptyCellRow = row;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tP_IFNOT(dir &amp;lt; eDIR_LEN, dir);\n\t\t\tbreak;\n\t\t}\n\n\t\treturn numMerges;\n\t}\n\nGitHub\n\n\n  Game2048\n\n\n\n"
} ,
  
  {
    "title"    : "Avoid Zeros",
    "category" : "",
    "tags"     : " cpp, dynamic-programming, mathematics, big-number, dfs-pitfall",
    "url"      : "/algoguru/2019/07/17/Avoid-Zeros.html",
    "date"     : "July 17, 2019",
    "excerpt"  : "https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWqPrpnKSCQDFAT_&amp;amp;categoryId=AWqPrpnKSCQDFAT_&amp;amp;categoryType=CODE\n\nSource\n\n\texplicit CProbSolve(const int N) {\n\t\tm_minZeros = INF;\n\t\tm_mapSizeN = N;\n\t\tP_IFNOT(m_...",
  "content"  : "https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWqPrpnKSCQDFAT_&amp;amp;categoryId=AWqPrpnKSCQDFAT_&amp;amp;categoryType=CODE\n\nSource\n\n\texplicit CProbSolve(const int N) {\n\t\tm_minZeros = INF;\n\t\tm_mapSizeN = N;\n\t\tP_IFNOT(m_mapSizeN &amp;gt;= 2 , m_mapSizeN);\n\t\tP_IFNOT(m_mapSizeN &amp;lt;= 1000, m_mapSizeN);\n\n\t\tFOR(row, m_mapSizeN) {\n\t\t\tvii viiRow;\n\t\t\tvi viRow;\n\t\t\tFOR(col, m_mapSizeN) {\n\t\t\t\tint val = 0;\n\t\t\t\tcin &amp;gt;&amp;gt; val;\n\t\t\t\tP_IFNOT(val &amp;gt;= 0, val);\n\t\t\t\tint numTwos = INF;\n\t\t\t\tint numFives = INF;\n\t\t\t\tif (val &amp;gt; 0) {\n\t\t\t\t\tnumTwos = _CountFactor(2, val);\n\t\t\t\t\tnumFives = _CountFactor(5, val);\n\t\t\t\t}\n\t\t\t\tviiRow.push_back(ii(numTwos, numFives));\n\t\t\t\tviRow.push_back(val);\n\t\t\t}\n\t\t\tm_map.push_back(viiRow);\n\t\t\tm_mapCanGo.push_back(viRow);\n\t\t}\n\n\t\t_Solve();\n\t}\n\n\tint _CountFactor(const int factor, const int val) {\n\t\tint cnt = 0;\n\t\tint quotient = val;\n\t\twhile (quotient % factor == 0) {\n\t\t\tquotient /= factor;\n\t\t\tcnt++;\n\t\t}\n\t\treturn cnt;\n\t}\n\n\tvoid _UpdateFactorMap() {\n\t\tFOR_INC(row, 1, m_mapSizeN) {\n\t\t\tm_map[row][0].first += m_map[row - 1][0].first;\n\t\t\tif (m_map[row][0].first &amp;gt; INF) m_map[row][0].first = INF;\n\t\t\tm_map[row][0].second += m_map[row - 1][0].second;\n\t\t\tif (m_map[row][0].second &amp;gt; INF) m_map[row][0].second = INF;\n\t\t}\n\t\tFOR_INC(col, 1, m_mapSizeN) {\n\t\t\tm_map[0][col].first += m_map[0][col - 1].first;\n\t\t\tif (m_map[0][col].first &amp;gt; INF) m_map[0][col].first = INF;\n\t\t\tm_map[0][col].second += m_map[0][col - 1].second;\n\t\t\tif (m_map[0][col].second &amp;gt; INF) m_map[0][col].second = INF;\n\t\t}\n\t\tFOR_INC(row, 1, m_mapSizeN) {\n\t\t\tFOR_INC(col, 1, m_mapSizeN) {\n\t\t\t\tm_map[row][col].first += _min(m_map[row - 1][col].first, m_map[row][col - 1].first);\n\t\t\t\tif (m_map[row][col].first &amp;gt; INF) m_map[row][col].first = INF;\n\t\t\t\tm_map[row][col].second += _min(m_map[row - 1][col].second, m_map[row][col - 1].second);\n\t\t\t\tif (m_map[row][col].second &amp;gt; INF) m_map[row][col].second = INF;\n\t\t\t}\n\t\t}\n\t\tm_minZeros = _min(m_map[m_mapSizeN - 1][m_mapSizeN - 1].first, m_map[m_mapSizeN - 1][m_mapSizeN - 1].second);\n\t}\n\nGitHub\n\n\n  AvoidZeros\n\n\n\n"
} ,
  
  {
    "title"    : "Naming Daughter",
    "category" : "",
    "tags"     : " cpp, bfs-with-generations, unique-and-erase-vector",
    "url"      : "/algoguru/2019/07/16/Naming-Daughter.html",
    "date"     : "July 16, 2019",
    "excerpt"  : "https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWm8hNu6llcDFASj&amp;amp;categoryId=AWm8hNu6llcDFASj&amp;amp;categoryType=CODE\n\nSource\n\n\tvoid _BFSWithUniqueAndSmallest(const ii &amp;amp;start) {\n\t\tm_ans = m_map[start.first][start....",
  "content"  : "https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWm8hNu6llcDFASj&amp;amp;categoryId=AWm8hNu6llcDFASj&amp;amp;categoryType=CODE\n\nSource\n\n\tvoid _BFSWithUniqueAndSmallest(const ii &amp;amp;start) {\n\t\tm_ans = m_map[start.first][start.second];\n\t\tm_posQ.push(start);\n\t\twhile (true) {\n\t\t\twhile (!m_posQ.empty()) {\n\t\t\t\tconst ii pos = m_posQ.front(); m_posQ.pop();\n\t\t\t\tFOR(dir, eDIR_LEN) {\n\t\t\t\t\tconst ii nextPos = ii(pos.first + DIR[dir][0], pos.second + DIR[dir][1]);\n\t\t\t\t\tif (OOR(nextPos.first, 0, (int)(m_rows - 1))) continue;\n\t\t\t\t\tif (OOR(nextPos.second, 0, (int)(m_cols - 1))) continue;\n#if 0 // it works sometimes\n\t\t\t\t\tconst string candName = m_ans + m_map[nextPos.first][nextPos.second];\n\t\t\t\t\tif (candName.compare(m_visit[nextPos.first][nextPos.second]) &amp;lt; 0) {\n\t\t\t\t\t\tm_visit[nextPos.first][nextPos.second] = candName;\n\t\t\t\t\t\tm_viiPos.push_back(nextPos);\n\t\t\t\t\t}\n#else\n\t\t\t\t\tm_viiPos.push_back(nextPos);\n#endif // 0\n\t\t\t\t}\n\t\t\t}\n\t\t\tm_viiPos.erase(unique(m_viiPos.begin(), m_viiPos.end()), m_viiPos.end());\n\t\t\tconst int numCands = m_viiPos.size();\n\t\t\tif (numCands == 0) return;\n\n\t\t\tchar earlistC = m_map[m_viiPos[0].first][m_viiPos[0].second];\n\t\t\tFOR_INC(i, 1, numCands) {\n\t\t\t\tconst char ch = m_map[m_viiPos[i].first][m_viiPos[i].second];\n\t\t\t\tif (ch &amp;lt; earlistC) {\n\t\t\t\t\tearlistC = ch;\n\t\t\t\t}\n\t\t\t}\n\t\t\tm_ans.push_back(earlistC);\n\t\t\tif ((m_viiPos.front().first == (int)(m_rows - 1)) &amp;amp;&amp;amp; (m_viiPos.front().second == (int)(m_cols - 1))) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tFOR(i, numCands) {\n\t\t\t\tif (m_map[m_viiPos[i].first][m_viiPos[i].second] == earlistC) {\n\t\t\t\t\tm_posQ.push(m_viiPos[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tm_viiPos.clear();\n\t\t}\n\t}\n\nGitHub\n\n\n  NamingDaughter\n\n\n\n"
} ,
  
  {
    "title"    : "Hiking Trail",
    "category" : "",
    "tags"     : " cpp, dfs-with-backtracking",
    "url"      : "/algoguru/2019/07/16/Hiking-Trail.html",
    "date"     : "July 16, 2019",
    "excerpt"  : "https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV5PoOKKAPIDFAUq\n\nSource\n\n\tvoid _DFS(const ii&amp;amp; pos, const int dist, const bool bDigged) {\n\t\t// Visit!\n\n\t\tm_map[pos.first][pos.second].first = 1;\n\t\tconst int heigh...",
  "content"  : "https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV5PoOKKAPIDFAUq\n\nSource\n\n\tvoid _DFS(const ii&amp;amp; pos, const int dist, const bool bDigged) {\n\t\t// Visit!\n\n\t\tm_map[pos.first][pos.second].first = 1;\n\t\tconst int height = m_map[pos.first][pos.second].second;\n\n\t\tif (dist &amp;gt; m_maxDist)\n\t\t{\n\t\t\tm_maxDist = dist;\n\t\t}\n\n\t\t// Check if it&#39;s a deepest point\n\n\t\tif (height == m_deepest)\n\t\t{\n\t\t\tif (bDigged == 1) {\n\t\t\t\tm_map[pos.first][pos.second].first = 0; // backtracking!\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif ((size_t)dist == m_mapSizeN * m_mapSizeN) {\n\t\t\tm_map[pos.first][pos.second].first = 0; // backtracking!\n\n\t\t\treturn;\n\t\t}\n\n\t\t// look up 4 dirs\n\n\t\tFOR(dir, eDIR_LEN) {\n\t\t\tconst ii nextPos(pos.first + DIR[dir][0], pos.second + DIR[dir][1]);\n\t\t\tif (OOR(nextPos.first, 0, (int)m_mapSizeN - 1)) continue;\n\t\t\tif (OOR(nextPos.second, 0, (int)m_mapSizeN - 1)) continue;\n\t\t\tif (m_map[nextPos.first][nextPos.second].first) continue;\n\t\t\tconst int nextH = m_map[nextPos.first][nextPos.second].second;\n\t\t\tif (bDigged == 0) {\n\t\t\t\t// with optional digging\n\n\t\t\t\tif ((height - (nextH - (int)m_maxDigK)) &amp;lt;= 0) continue;\n\t\t\t\tint digging = height - nextH;\n\t\t\t\tif (digging &amp;lt;= 0) {\n\t\t\t\t\tP_IFNOT((1 - digging) &amp;lt;= (int)m_maxDigK, height);\n\t\t\t\t\tP_IFNOT((1 - digging) &amp;lt;= (int)m_maxDigK, nextH);\n\t\t\t\t\tP_IFNOT((1 - digging) &amp;lt;= (int)m_maxDigK, digging);\n\t\t\t\t\tm_map[nextPos.first][nextPos.second].second = nextH + (digging-1);\n\t\t\t\t\t_DFS(nextPos, dist + 1, 1);\n\t\t\t\t\t// backtracking!\n\n\t\t\t\t\tm_map[nextPos.first][nextPos.second].second = nextH;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// without digging\n\n\t\t\t\tif (height - nextH &amp;lt;= 0) continue;\n\t\t\t}\n\t\t\t_DFS(nextPos, dist + 1, bDigged);\n\t\t}\n\n\t\tm_map[pos.first][pos.second].first = 0; // backtracking!\n\n\t}\n\nGitHub\n\n\n  HikingTrail\n\n\n\n"
} ,
  
  {
    "title"    : "Sample post",
    "category" : "",
    "tags"     : " A Tag, Katex",
    "url"      : "/algoguru/2019/06/30/sample-post.html",
    "date"     : "June 30, 2019",
    "excerpt"  : "Consectetur adipiscing elit. Donec a diam lectus. Sed sit amet ipsum mauris. Maecenas congue ligula ac quam viverra nec consectetur ante hendrerit. Donec et mollis dolor. \nPraesent et diam eget libero egestas mattis sit amet vitae augue. Nam tinci...",
  "content"  : "Consectetur adipiscing elit. Donec a diam lectus. Sed sit amet ipsum mauris. Maecenas congue ligula ac quam viverra nec consectetur ante hendrerit. Donec et mollis dolor. \nPraesent et diam eget libero egestas mattis sit amet vitae augue. Nam tincidunt congue enim, ut porta lorem lacinia consectetur. \n\nDonec ut libero sed arcu vehicula ultricies a non tortor. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean ut gravida lorem.\n\n\n  Consectetur adipiscing elit\n  Donec a diam lectus\n  Sed sit amet ipsum mauris\n\n\nUt turpis felis, pulvinar a semper sed, adipiscing id dolor. Pellentesque auctor nisi id magna consequat sagittis. Curabitur dapibus enim sit amet elit pharetra tincidunt feugiat nisl imperdiet. Ut convallis libero in urna ultrices accumsan. Donec sed odio eros. Donec viverra mi quis quam pulvinar at malesuada arcu rhoncus. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. In rutrum accumsan ultricies. Mauris vitae nisi at sem facilisis semper ac in est.\n\nNunc diam velit, adipiscing ut tristique vitae, sagittis vel odio. Maecenas convallis ullamcorper ultricies. Curabitur ornare, ligula semper consectetur sagittis, nisi diam iaculis velit, id fringilla sem nunc vel mi. Nam dictum, odio nec pretium volutpat, arcu ante placerat erat, non tristique elit urna et turpis. Quisque mi metus, ornare sit amet fermentum et, tincidunt et orci. Fusce eget orci a orci congue vestibulum.\n\n\n    \n    \n        \n    \n    \n\n\nUt dolor diam, elementum et vestibulum eu, porttitor vel elit. Curabitur venenatis pulvinar tellus gravida ornare. Sed et erat faucibus nunc euismod ultricies ut id justo. Nullam cursus suscipit nisi, et ultrices justo sodales nec. Fusce venenatis facilisis lectus ac semper. Aliquam at massa ipsum. Quisque bibendum purus convallis nulla ultrices ultricies. Nullam aliquam, mi eu aliquam tincidunt, purus velit laoreet tortor, viverra pretium nisi quam vitae mi. Fusce vel volutpat elit. Nam sagittis nisi dui.\n\n\n  Suspendisse lectus leo, consectetur in tempor sit amet, placerat quis neque\n\n\nEtiam luctus porttitor lorem, sed suscipit est rutrum non. Curabitur lobortis nisl a enim congue semper. Aenean commodo ultrices imperdiet. Vestibulum ut justo vel sapien venenatis tincidunt.\n\n\\[\\Theta \\ne \\Gamma\\]\n\nPhasellus eget dolor sit amet ipsum dapibus condimentum vitae quis lectus. Aliquam ut massa in turpis dapibus convallis. Praesent elit lacus, vestibulum at malesuada et, ornare et est. Ut augue nunc, sodales ut euismod non, adipiscing vitae orci1. Mauris ut placerat justo. Mauris in ultricies enim. Quisque nec est eleifend nulla ultrices egestas quis ut quam. Donec sollicitudin lectus a mauris pulvinar id aliquam urna cursus. Cras quis ligula sem, vel elementum mi. Phasellus non ullamcorper urna.\n\n\n  \n    \n\n      John Smith, A Title About Citations &amp;#8617;\n    \n  \n\n"
} ,
  
  {
    "title"    : "LED On Off Pattern",
    "category" : "",
    "tags"     : " cpp, simple-implementation, difference-from-model",
    "url"      : "/algoguru/2019/06/22/LED-on-off-pattern.html",
    "date"     : "June 22, 2019",
    "excerpt"  : "http://codepro.lge.com/apply/exam/ZXhfaUhjUkhfMTQ5NTQ5NjY4ODY3NQ==/quiz/cV91QXRuY18xNTM4NDY2MjA3OTE2\n\nSource\n\nvoid FindViolationPatterns(vector&amp;lt;vii&amp;gt; &amp;amp;vviiCandLists)\n{\n\tS[N] = 2;\n\tFOR(even, 2){\n\t\tvi viAB;\n\t\tii iiCand(-1,-1);\n\t\tvii viiCand...",
  "content"  : "http://codepro.lge.com/apply/exam/ZXhfaUhjUkhfMTQ5NTQ5NjY4ODY3NQ==/quiz/cV91QXRuY18xNTM4NDY2MjA3OTE2\n\nSource\n\nvoid FindViolationPatterns(vector&amp;lt;vii&amp;gt; &amp;amp;vviiCandLists)\n{\n\tS[N] = 2;\n\tFOR(even, 2){\n\t\tvi viAB;\n\t\tii iiCand(-1,-1);\n\t\tvii viiCandList;\n\t\tFOR(idx, N){\n\t\t\tconst int i = (idx + even) % 2;\n\t\t\tviAB.push_back(i);\n\t\t\tCollectCand(idx, viAB, iiCand, viiCandList);\n\t\t}\n\t\tviAB.push_back(2);\n\t\tCollectCand(N, viAB, iiCand, viiCandList);\n\n\t\tvviiCandLists.push_back(viiCandList);\n\t}\n}\n\n\nint FindMaxLengthWithFlip(const vector&amp;lt;vii&amp;gt; &amp;amp;vviiCandLists)\n{\n\tint maxLen = 0;\n\tFOR(i, 2){\n\t\tii range(-1,-1);\n\t\tint nextBegin = -1;\n\t\tconst int numLoops = (int)vviiCandLists.at(i).size();\n\t\tFOR(j, numLoops){\n\t\t\tif(j &amp;gt; 0){\n\t\t\t\trange.second = vviiCandLists.at(i).at(j).first;\n\t\t\t\tCheckMaxLenRange(range, maxLen);\n\t\t\t\trange.first = nextBegin;\n\t\t\t}\n\t\t\tnextBegin = vviiCandLists.at(i).at(j).second;\n\t\t}\n\n\t\trange.second = N;\n\t\tCheckMaxLenRange(range, maxLen);\n\t}\n\treturn maxLen;\n}\n\nGitHub\n\n\n  LED_OnOffPattern\n\n\n\n"
} ,
  
  {
    "title"    : "Permutation Cycles",
    "category" : "",
    "tags"     : " cpp, unordered-set, STL",
    "url"      : "/algoguru/2019/06/18/perm-cycles.html",
    "date"     : "June 18, 2019",
    "excerpt"  : "https://www.acmicpc.net/problem/10451\n\nSource\n\n        FOR(i, m_N){\n            usi::iterator it = m_usiPerm.find(i+1);\n            if(it == m_usiPerm.end()){\n                continue;\n            }\n            m_usiPerm.erase(it);\n\n            if...",
  "content"  : "https://www.acmicpc.net/problem/10451\n\nSource\n\n        FOR(i, m_N){\n            usi::iterator it = m_usiPerm.find(i+1);\n            if(it == m_usiPerm.end()){\n                continue;\n            }\n            m_usiPerm.erase(it);\n\n            if (m_viPerm.at(i) == i+1){\n                cycleCnt++;\n            }\n            else{\n                int nodeFrom = i+1;\n                int nodeTo = m_viPerm.at(nodeFrom-1);\n                while(nodeTo != (i+1)){\n                    usi::iterator delit = m_usiPerm.find(nodeTo);\n                    if(W_IFNOT(delit != m_usiPerm.end()));\n                    else {\n                        break;\n                    }\n                    m_usiPerm.erase(delit);\n                    nodeFrom = nodeTo;\n                    nodeTo = m_viPerm.at(nodeFrom-1);\n                    P_IFNOT(nodeTo &amp;lt;= m_N, nodeTo);\n                }\n                cycleCnt++;\n            }\n        }\n\nGitHub\n\n\n  PermCycles\n\n\n\n"
} ,
  
  {
    "title"    : "Color Post",
    "category" : "",
    "tags"     : " Test, Color",
    "url"      : "/algoguru/blogging/2019/05/18/color-post.html",
    "date"     : "May 18, 2019",
    "excerpt"  : "What a colorful post!\n\nThis is an idea that came from xukimseven/HardCandy-Jekyll\nlooking at this cheerful and colorful theme, I wanted to enable something similar for Type-on-Strap.\n\nYou can go fork and star HardCandy-Jekyll too! 😉\n\n\n\nHow does it...",
  "content"  : "What a colorful post!\n\nThis is an idea that came from xukimseven/HardCandy-Jekyll\nlooking at this cheerful and colorful theme, I wanted to enable something similar for Type-on-Strap.\n\nYou can go fork and star HardCandy-Jekyll too! 😉\n\n\n\nHow does it work?\n\nBasically you need to add just one thing, the color:\n\n---\nlayout: post\ntitle: Color Post\ncolor: brown\n---\n\n\nIt can either be a html color like brown (which look like red to me). Or with the rgb:\n\n---\nlayout: post\ntitle: Color Post\ncolor: rgb(165,42,42)\n---\n\n\nThe background used is lineart.png from xukimseven you can edit it in the config file.\nIf you want another one, put it in /assets/img as well.\n\n\n  ⚠️ It’s a bit hacking the css in the post.html\n\n"
} ,
  
  {
    "title"    : "String Editor",
    "category" : "",
    "tags"     : " cpp, STL, list",
    "url"      : "/algoguru/2019/04/28/string-editor.html",
    "date"     : "April 28, 2019",
    "excerpt"  : "https://www.acmicpc.net/problem/1406\n\nSource\n\nint Left(int pos){\n    if (pos &amp;lt;= 0) return pos;\n    pos--;\n    itPos--;\n    return pos;\n}\n\nint Right(int pos){\n    if (pos &amp;gt;= len) return pos;\n    pos++;\n    itPos++;\n    return pos;\n}\n\nint Del(...",
  "content"  : "https://www.acmicpc.net/problem/1406\n\nSource\n\nint Left(int pos){\n    if (pos &amp;lt;= 0) return pos;\n    pos--;\n    itPos--;\n    return pos;\n}\n\nint Right(int pos){\n    if (pos &amp;gt;= len) return pos;\n    pos++;\n    itPos++;\n    return pos;\n}\n\nint Del(int pos){\n    if (pos &amp;lt;= 0) return pos;\n    lc::iterator it = itPos;\n    lcL.erase(--it);\n    len = (int)lcL.size();\n    return --pos;\n}\n\nint Ins(int pos, char alpha){\n    if (pos &amp;lt; 0) return pos;\n    if (pos &amp;gt; len) return pos;\n    lcL.insert(itPos, alpha);\n    len = (int)lcL.size();\n    return ++pos;\n}\n\nvoid EditStr(const int numCmds){\n    int pos = ParseStr();\n    FOR(i, numCmds){\n        char a = cmd[i];\n        switch(a){\n        case 1:\n            pos = Left(pos);\n            break;\n        case 2:\n            pos = Right(pos);\n            break;\n        case 3:\n            pos = Del(pos);\n            break;\n        default:\n            pos = Ins(pos, a);\n            break;\n        }\n    }\n}\n\nGitHub\n\n\n  StringEditor\n\n\n\n"
} ,
  
  {
    "title"    : "Connect Pipes",
    "category" : "",
    "tags"     : " cpp, dfs, bfs, STL, queue",
    "url"      : "/algoguru/2019/04/25/connect-pipes.html",
    "date"     : "April 25, 2019",
    "excerpt"  : "http://codepro.lge.com/apply/exam/ZXhfaUhjUkhfMTQ5NTQ5NjY4ODY3NQ==/quiz/cV9pb05sYl8xNTIwODUyOTU2ODc1\n\nSource\n\nenum eDir{\n\teD = 0,\n\teR,\n\teU,\n\teL,\n\tNUM_DIRS\n};\nconst int NUM_PIPE_KINDS = 12;\nconst int N_DIR[NUM_DIRS] = {eU, eL, eD, eR};\nconst int DI...",
  "content"  : "http://codepro.lge.com/apply/exam/ZXhfaUhjUkhfMTQ5NTQ5NjY4ODY3NQ==/quiz/cV9pb05sYl8xNTIwODUyOTU2ODc1\n\nSource\n\nenum eDir{\n\teD = 0,\n\teR,\n\teU,\n\teL,\n\tNUM_DIRS\n};\nconst int NUM_PIPE_KINDS = 12;\nconst int N_DIR[NUM_DIRS] = {eU, eL, eD, eR};\nconst int DIR[NUM_DIRS][2] = { {1,0},{0,1},{-1,0},{0,-1} };\nconst int CAN_GO[NUM_PIPE_KINDS][NUM_DIRS] = {\n\t{0,0,0,0},\n\t{0,1,0,1},\n\t{1,0,1,0},\n\t{1,1,0,0},\n\t{1,0,0,1},\n\t{0,0,1,1},\n\t{0,1,1,0},\n\t{1,1,1,0},\n\t{1,1,0,1},\n\t{1,0,1,1},\n\t{0,1,1,1},\n\t{1,1,1,1},\n};\n\nint visit[MAX_N][MAX_N] = {0,};\nint CheckRangeFlagPipe(const ii nextPos, const int dir){\n\tif (visit[nextPos.first][nextPos.second] != 0) return 0;\n\tif (OOR(nextPos.first, 0, N-1)) return 0;\n\tif (OOR(nextPos.second, 0, N-1)) return 0;\n\tint nextDir = N_DIR[dir];\n\treturn CAN_GO[map[nextPos.first][nextPos.second]][nextDir];\n}\n\nint cnt = 0;\nvoid DFS(const ii pos){\n\tvisit[pos.first][pos.second] = ++cnt;\n\tFOR(dir, NUM_DIRS){\n\t\tif (CAN_GO[map[pos.first][pos.second]][dir] == 0) continue;\n\t\tii nextPos(pos.first+DIR[dir][0], pos.second+DIR[dir][1]);\n\t\tif (CheckRangeFlagPipe(nextPos, dir)){\n\t\t\tDFS(nextPos);\n\t\t}\n\t}\n}\n\nqii iiPosQ;\nvoid BFS(const ii start){\n\tvisit[start.first][start.second] = ++cnt;\n\tiiPosQ.push(start);\n\twhile(!iiPosQ.empty()){\n\t\tii pos = iiPosQ.front(); iiPosQ.pop();\n\t\tFOR(dir, NUM_DIRS){\n\t\t\tif (CAN_GO[map[pos.first][pos.second]][dir] == 0) continue;\n\t\t\tii nextPos(pos.first+DIR[dir][0], pos.second+DIR[dir][1]);\n\t\t\tif (CheckRangeFlagPipe(nextPos, dir)){\n\t\t\t\tvisit[nextPos.first][nextPos.second] = ++cnt;\n\t\t\t\tiiPosQ.push(nextPos);\n\t\t\t}\n\t\t}\n\t}\n}\n\nGitHub\n\n\n  ConnectPipes\n\n\n\n"
} ,
  
  {
    "title"    : "Warehouse",
    "category" : "",
    "tags"     : " cpp, floyd-warshall",
    "url"      : "/algoguru/2019/04/22/warehouse.html",
    "date"     : "April 22, 2019",
    "excerpt"  : "http://codepro.lge.com/apply/exam/ZXhfaUhjUkhfMTQ5NTQ5NjY4ODY3NQ==/quiz/cV9RRUxqRl8xNTU0Nzg1OTIzMzg0\n\nSource\n\n// Init\n\nFOR(i, N){\n    FOR(j, N){\n        if (i == j)\n            arDist[i][j] = 0;\n        else\n            arDist[i][j] = INF;\n    }\n}...",
  "content"  : "http://codepro.lge.com/apply/exam/ZXhfaUhjUkhfMTQ5NTQ5NjY4ODY3NQ==/quiz/cV9RRUxqRl8xNTU0Nzg1OTIzMzg0\n\nSource\n\n// Init\n\nFOR(i, N){\n    FOR(j, N){\n        if (i == j)\n            arDist[i][j] = 0;\n        else\n            arDist[i][j] = INF;\n    }\n}\nFOR(i, M){\n    arDist[A[i]-1][B[i]-1] = D[i];\n    arDist[B[i]-1][A[i]-1] = D[i];\n}\n\n// Update with Floyd\n\nFOR(k, N){\n    FOR(i, N){\n        if (arDist[i][k] == INF) continue;\n        FOR(j, N){\n            arDist[i][j] = min(arDist[i][j], arDist[i][k]+arDist[k][j]);\n        }\n    }\n}\n\n// Find min worst\n\nint minWorst = INF;\nFOR(k, N){\n    int worst = 0;\n    FOR(i, N){\n        if (k==i) continue;\n        int&amp;amp; dist = arDist[k][i];\n        W_IFNOT(dist &amp;gt; 0);\n        if (dist == INF) continue;\n        W_IFNOT(dist &amp;lt; INF);\n        if (dist &amp;gt; worst)\n            worst = dist;\n    }\n    if (worst==0) continue;\n    if (worst &amp;lt; minWorst)\n        minWorst = worst;\n}\nans = minWorst;\n\nGitHub\n\n\n  Warehouse\n\n\n\n"
} ,
  
  {
    "title"    : "Circle List Order",
    "category" : "",
    "tags"     : " cpp, list, STL, advance",
    "url"      : "/algoguru/2019/04/22/circle-list-order.html",
    "date"     : "April 22, 2019",
    "excerpt"  : "http://codepro.lge.com/apply/exam/ZXhfaUhjUkhfMTQ5NTQ5NjY4ODY3NQ==/quiz/cV9XWmVFZV8xNTU0Nzg1OTIzNDE0\n\nSource\n\nint curN = N;\nint curS = S-1;\nconst int constM = M-1;\n\nli numL;\nFOR(i, curN){\n    numL.push_back(i+1);\n}\n\nli::iterator it = numL.begin();...",
  "content"  : "http://codepro.lge.com/apply/exam/ZXhfaUhjUkhfMTQ5NTQ5NjY4ODY3NQ==/quiz/cV9XWmVFZV8xNTU0Nzg1OTIzNDE0\n\nSource\n\nint curN = N;\nint curS = S-1;\nconst int constM = M-1;\n\nli numL;\nFOR(i, curN){\n    numL.push_back(i+1);\n}\n\nli::iterator it = numL.begin();\n\nFOR(i, N){\n    int chosen = (curS+constM)%curN;\n    \n    advance(it, chosen);\n    cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &quot; &quot;;\n    numL.erase(it);\n    it = numL.begin();\n    \n    curS = chosen;\n    curN = numL.size();\n}\n\nGitHub\n\n\n  CircleListOrder\n\n\n\n"
} ,
  
  {
    "title"    : "UnitTest: Drone Go",
    "category" : "",
    "tags"     : " cpp, simple-implementation, unittest",
    "url"      : "/algoguru/2019/04/09/unittest-drone-go.html",
    "date"     : "April 9, 2019",
    "excerpt"  : "Description\n\n\n  Unit Test 작성\n\n\nSource\n\n/**\n * (y, x) 좌표를 표현하는 자료구조\n *\ntypedef struct pos {\n\tint y;\n\tint x;\n} POS;\n\n/**\n * 화재 감지 센서 인터페이스\n *\nclass FireSensor\n{\npublic:\n\t/**\n\t * 현재 화재를 감지한 센서의 위치 값을 반환\n\t * @return POS 타입의 (y, x) 좌표. 예를 들어, 1번 센서에서 화...",
  "content"  : "Description\n\n\n  Unit Test 작성\n\n\nSource\n\n/**\n * (y, x) 좌표를 표현하는 자료구조\n *\ntypedef struct pos {\n\tint y;\n\tint x;\n} POS;\n\n/**\n * 화재 감지 센서 인터페이스\n *\nclass FireSensor\n{\npublic:\n\t/**\n\t * 현재 화재를 감지한 센서의 위치 값을 반환\n\t * @return POS 타입의 (y, x) 좌표. 예를 들어, 1번 센서에서 화재를 감지한 경우 {1, 10}을 반환\n\t *\n\tvirtual POS getSensorPosition() = 0;\n};\n\n/**\n * 드론 관제 시스템 (테스트 대상)\n *\nclass DroneController\n{\n\tPOS currentDrone1_ = { 0,0 };\n\tPOS currentDrone2_ = { 10,10 };\n\n\tFireSensor* sensor_;\n\t...\npublic:\n\tDroneController(FireSensor* sensor) : sensor_(sensor) { ... }\n\n\t/**\n\t * 화재가 발생한 위치를 얻어와서 현재 드론과의 위치를 계산하여 가장 가까운 드론을 선택하는 함수 (테스트 대상)\n\t * 다음 위치 계산을 위해 선택된 드론의 위치를 저장해둔다. (선택된 드론이 해당 좌표로 이동함을 가정)\n\t * @return 화재가 발생한 곳과 가장 가까운 드론의 번호. 1 혹은 2\n\t *\n\tint selectDrone()\n\t{\n\t\tPOS sensed = sensor_-&amp;gt;getSensorPosition();  // 화제를 감지한 센서의 위치 획득\n\n\n\t\tint dx = currentDrone1_.x - sensed.x;\n\t\tint dy = currentDrone1_.y - sensed.y;\n\t\tint dist1 = dx*dx + dy*dy;\n\n\t\tdx = currentDrone2_.x - sensed.x;\n\t\tdy = currentDrone2_.y - sensed.y;\n\t\tint dist2 = dx*dx + dy*dy;\n\n\t\tif (dist2 &amp;gt;= dist1)\n\t\t{\n\t\t\tcurrentDrone1_ = sensed;\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcurrentDrone2_ = sensed;\n\t\t\treturn 2;\n\t\t}\n\t}\n\t...\n}\n\nmake Stub Class\n\n// 문제 3. 테스트 코드 작성\n\nclass StubSensor: public FireSensor\n{\npublic:\n\tPOS m_testPos;\n\tPOS getSensorPosition(){\n\t\treturn m_testPos;\n\t}\n};\n\nvoid test_3_1()\n{\n\t// TODO: 항목 3-1.\n\n\t// 화재 위치가 센서 1, 7, 2, 3, 5 순으로 감지되는 상황을 재현하는 테스트 코드\n\n\tStubSensor sensor;\n\tDroneController dc((FireSensor*)&amp;amp;sensor);\n\tsensor.m_testPos.y = 1; sensor.m_testPos.x = 10;\n\tdc.selectDrone();\n\tsensor.m_testPos.y = 8; sensor.m_testPos.x = 2;\n\tdc.selectDrone();\n\tsensor.m_testPos.y = 2; sensor.m_testPos.x = 6;\n\tdc.selectDrone();\n\tsensor.m_testPos.y = 4; sensor.m_testPos.x = 1;\n\tdc.selectDrone();\n\tsensor.m_testPos.y = 6; sensor.m_testPos.x = 10;\n\tdc.selectDrone();\n}\n\nGitHub (n/a)\n\n\n"
} ,
  
  {
    "title"    : "Mario game",
    "category" : "",
    "tags"     : " cpp, simple-implementation",
    "url"      : "/algoguru/2019/04/08/mario-game.html",
    "date"     : "April 8, 2019",
    "excerpt"  : "http://codepro.lge.com/apply/exam/ZXhfaUhjUkhfMTQ5NTQ5NjY4ODY3NQ==/quiz/cV9oUmVJa18xNTQ5ODUxNTIxMDEy\n\nSource\n\nconst int FindMaxH(const int N, const int (&amp;amp;P)[MAX_N])\n{\n\tint h = 0;\n\tint ud = 1;\n\tfor (int i=0; i&amp;lt;N; i++){\n\t\tif(ud == 1){\n\t\t\tif(P...",
  "content"  : "http://codepro.lge.com/apply/exam/ZXhfaUhjUkhfMTQ5NTQ5NjY4ODY3NQ==/quiz/cV9oUmVJa18xNTQ5ODUxNTIxMDEy\n\nSource\n\nconst int FindMaxH(const int N, const int (&amp;amp;P)[MAX_N])\n{\n\tint h = 0;\n\tint ud = 1;\n\tfor (int i=0; i&amp;lt;N; i++){\n\t\tif(ud == 1){\n\t\t\tif(P[i] &amp;gt; P[i+1]){\n\t\t\t\t// go down\n\n\t\t\t\th += P[i];\n\t\t\t\tud = -1;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(P[i] &amp;lt; P[i+1]){\n\t\t\t\t// go up\n\n\t\t\t\th -= P[i];\n\t\t\t\tud = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn h;\n}\n\nGitHub\n\n\n  MarioGame\n\n\n\n"
} ,
  
  {
    "title"    : "Feature images",
    "category" : "",
    "tags"     : " Test, Image",
    "url"      : "/algoguru/blogging/2018/10/29/feature-images.html",
    "date"     : "October 29, 2018",
    "excerpt"  : "Hopefully you will find enough information about how to set images in your blog here.\nThis is an example of a post which includes a feature image specified in the front matter of the post.\nThe feature image spans the full-width of the page, and is...",
  "content"  : "Hopefully you will find enough information about how to set images in your blog here.\nThis is an example of a post which includes a feature image specified in the front matter of the post.\nThe feature image spans the full-width of the page, and is shown with the title on permalink pages:\n\nfeature-img: &quot;assets/img/feature-img/desk-messy.jpeg&quot;\nthumbnail: &quot;assets/img/thumbnails/feature-img/desk-messy.jpeg&quot;\n\n\nYou can also use a thumbnail, a smaller version of the same image to improve loading of the page.\nThe thumbnail will also be used when you share your article on other platform (linkedin, whatsapp, facebook, …).\n\n\n  \n    And now it is working\n  \n\n\nYou can also add images aligned in your post using the aligner include.\nMake sure to separate all of the image path from in a string separated with ,.\nIt by default look into assets/img/ so give the path from there, example:\n\n{% include aligner.html images=&quot;pexels/book-glass.jpeg,triangle.png&quot; %}\n\n\n    \n    \n        \n    \n    \n    \n        \n    \n    \n\n\nHere you have two images side by side, but you can set more and set the amount per columns\n(by specifying the number of columns or let it be automatic using &quot;auto&quot;):\n\n{% include aligner.html images=&quot;portfolio/cabin.png,portfolio/cake.png,portfolio/circus.png&quot; column=3 %}\n\n\n    \n    \n        \n    \n    \n    \n        \n    \n    \n    \n        \n    \n    \n\n\nit also works with only one images, it is made to display it smaller than normally.\nHowever you can just use the Markdown way of doing it to get the image normal sized and centered.\n\n# Markdown way (bigger)\n![Travel]({{ &quot;/assets/img/pexels/computer.jpeg&quot; | relative_url}})\n# Aligner with only One (50% of width)\n{% include aligner.html images=&quot;pexels/computer.jpeg&quot; %}\n\n\n    \n    \n        \n    \n    \n\n\n"
} ,
  
  {
    "title"    : "Bootstrap",
    "category" : "",
    "tags"     : " Test",
    "url"      : "/algoguru/blogging/2017/09/17/Use-Bootstrap.html",
    "date"     : "September 17, 2017",
    "excerpt"  : "This theme is compatible with Bootstrap if you choose to use it in your pages or posts.\nHere is a little demo with a code snippet, look at the source to see how the HTML and markdown get tangled.\n\nUse bootstrap\n\nAdd some custom Bootstrap in the cu...",
  "content"  : "This theme is compatible with Bootstrap if you choose to use it in your pages or posts.\nHere is a little demo with a code snippet, look at the source to see how the HTML and markdown get tangled.\n\nUse bootstrap\n\nAdd some custom Bootstrap in the custom layout!\n\n\n\nSnippet example\n\nIf you are new to Bootstrap you can  always check the documentation.\nHere is an example from startbootstrap.com.\n\n\n\n\n  \n    \n      \n        \n        \n          \n            Project One\n          \n          Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nam viverra euismod odio, gravida pellentesque urna varius vitae.\n        \n      \n    \n    \n      \n        \n        \n          \n            Project Two\n          \n          Lorem ipsum dolor sit amet, consectetur adipisicing elit. Fugit aliquam aperiam nulla perferendis dolor nobis numquam, rem expedita, aliquid optio, alias illum eaque. Non magni, voluptates quae, necessitatibus unde temporibus.\n        \n      \n    \n    \n      \n        \n        \n          \n            Project Three\n          \n          Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nam viverra euismod odio, gravida pellentesque urna varius vitae.\n        \n      \n    \n    \n      \n        \n        \n          \n            Project Four\n          \n          Lorem ipsum dolor sit amet, consectetur adipisicing elit. Fugit aliquam aperiam nulla perferendis dolor nobis numquam, rem expedita, aliquid optio, alias illum eaque. Non magni, voluptates quae, necessitatibus unde temporibus.\n        \n      \n    \n    \n      \n        \n        \n          \n            Project Five\n          \n          Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nam viverra euismod odio, gravida pellentesque urna varius vitae.\n        \n      \n    \n    \n      \n        \n        \n          \n            Project Six\n          \n          Lorem ipsum dolor sit amet, consectetur adipisicing elit. Fugit aliquam aperiam nulla perferendis dolor nobis numquam, rem expedita, aliquid optio, alias illum eaque. Non magni, voluptates quae, necessitatibus unde temporibus.\n        \n      \n    \n  \n  \n\n\n\n\nMix it with Markdown\n\nAll the above was custom HTML with Bootstrap.\nYou can also mix it up with some markdown.\n\nYou can use the bootstrap’s build in javascript API to control your event.\nHere is a code snippet for the documentation:\n\n$(&#39;#myModal&#39;).on(&#39;show.bs.modal&#39;, function (e) {\n    if (!data) return e.preventDefault() // stops modal from being shown\n})\n\n\nThat’s just for demo though, you would need to properly integrate your javascript in your page.\nUsually you would put any custom javascript script in the assets folder under js and reference it in your page from there.\n\nSo try it out using the bootstrap: true flag! 😉\n"
} ,
  
  {
    "title"    : "Markdown and HTML",
    "category" : "",
    "tags"     : " Katex, Markdown",
    "url"      : "/algoguru/blogging/2014/11/28/markdown-and-html.html",
    "date"     : "November 28, 2014",
    "excerpt"  : "Jekyll supports the use of Markdown with inline HTML tags which makes it easier to quickly write posts with Jekyll, without having to worry too much about text formatting. A sample of the formatting follows.\n\nTable of content\n\n\n\n  TOC\n    *\nYou ne...",
  "content"  : "Jekyll supports the use of Markdown with inline HTML tags which makes it easier to quickly write posts with Jekyll, without having to worry too much about text formatting. A sample of the formatting follows.\n\nTable of content\n\n\n\n  TOC\n    *\nYou need to put this at the beginning of the page where you want the table of content to be displayed\n  \n\n\n* TOC\n{:toc}\n\n\nIt will then render the markdown and html titles (lines that begins with # or using the &amp;lt;h1&amp;gt;&amp;lt;/h1&amp;gt; tages)\n\nTitle\n\nSubtitle\n\nTables have also been extended from Markdown:\n\n\n  \n    \n      First Header\n      Second Header\n    \n  \n  \n    \n      Content Cell\n      Content Cell\n    \n    \n      Content Cell\n      Content Cell\n    \n  \n\n\nHere’s an example of an image, which is included using Markdown:\n\n\n\nThis is another example of list:\n\n\n  list of things\n    \n      Sub list\n      of Other things\n      with numbers\n    \n  \n  And many more\n    \n      Sub sub list\n        \n          can go on …\n            \n              and on …\n                \n                  and on !\n                \n              \n            \n          \n        \n      \n      That’s it.\n    \n  \n\n\nOther subtitle\n\nHighlighting for code in Jekyll is done using Base16 or Rouge. This theme makes use of Rouge by default.\n\n// count to ten\nfor (var i = 1; i &amp;lt;= 10; i++) {\n    console.log(i);\n}\n\n// count to twenty\nvar j = 0;\nwhile (j &amp;lt; 20) {\n    j++;\n    console.log(j);\n}\n\nMath\n\nType on Strap uses KaTeX to display maths. Equations such as \\(S_n = a \\times \\frac{1-r^n}{1-r}\\) can be displayed inline.\n\nAlternatively, they can be shown on a new line:\n\n\\[f(x) = \\int \\frac{2x^2+4x+6}{x-2}\\]\n"
} ,
  
  {
    "title"    : "What&#39;s your title",
    "category" : "",
    "tags"     : " Test, Image",
    "url"      : "/algoguru/2014/11/27/whats-your-title.html",
    "date"     : "November 27, 2014",
    "excerpt"  : "This is an example of a post which includes a feature image that has a\ntext, where you don’t want to redisplay the title.\nMind your image size in order for the text to be displayed where you want it to.\nThe only limit is your imagination.\n\nHere is...",
  "content"  : "This is an example of a post which includes a feature image that has a\ntext, where you don’t want to redisplay the title.\nMind your image size in order for the text to be displayed where you want it to.\nThe only limit is your imagination.\n\nHere is how the yaml looks inside the post:\n\ntitle: What&#39;s your title\nhide_title: true\nfeature-img: assets/img/feature-img/story.jpeg\nauthor: mhagnumdw\ntags: [Test, Lorem]\n\n\nYou may wonder, why is there a title when you are not actually displaying it. \nWell that’s due to some jekyll limitation:\n\n\n  You can’t set the title to the empty string\n\n\nThe title is used elsewhere than inside the post, for example in the blog page that list this post.\nAn empty title would break those pages and possibly prevents jekyll to render your blog.\n"
} ,
  
  {
    "title"    : "The Real Lorem Ipsum",
    "category" : "",
    "tags"     : " Image, Color",
    "url"      : "/algoguru/blogging/2014/11/26/lorem-ipsum.html",
    "date"     : "November 26, 2014",
    "excerpt"  : "Lorem Ipsum\n\nfrom “de Finibus Bonorum et Malorum” written by Cicero in 45 BC.\n \nFind out more on lipsum.com. And if you like colors, check out the http color trends from w3schools.\n\nThe standard Lorem Ipsum passage (since 1500s)\n\n“Lorem ipsum dolo...",
  "content"  : "Lorem Ipsum\n\nfrom “de Finibus Bonorum et Malorum” written by Cicero in 45 BC.\n \nFind out more on lipsum.com. And if you like colors, check out the http color trends from w3schools.\n\nThe standard Lorem Ipsum passage (since 1500s)\n\n“Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.”\n\nSection 1.10.32\n\nLatin\n“Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?”\n\nTranslation by H. Rackham (1914)\n“But I must explain to you how all this mistaken idea of denouncing pleasure and praising pain was born and I will give you a complete account of the system, and expound the actual teachings of the great explorer of the truth, the master-builder of human happiness. No one rejects, dislikes, or avoids pleasure itself, because it is pleasure, but because those who do not know how to pursue pleasure rationally encounter consequences that are extremely painful. Nor again is there anyone who loves or pursues or desires to obtain pain of itself, because it is pain, but because occasionally circumstances occur in which toil and pain can procure him some great pleasure. To take a trivial example, which of us ever undertakes laborious physical exercise, except to obtain some advantage from it? But who has any right to find fault with a man who chooses to enjoy a pleasure that has no annoying consequences, or one who avoids a pain that produces no resultant pleasure?”\n\nSection 1.10.33\n\nLatin\n\n“At vero eos et accusamus et iusto odio dignissimos ducimus qui blanditiis praesentium voluptatum deleniti atque corrupti quos dolores et quas molestias excepturi sint occaecati cupiditate non provident, similique sunt in culpa qui officia deserunt mollitia animi, id est laborum et dolorum fuga. Et harum quidem rerum facilis est et expedita distinctio. Nam libero tempore, cum soluta nobis est eligendi optio cumque nihil impedit quo minus id quod maxime placeat facere possimus, omnis voluptas assumenda est, omnis dolor repellendus. Temporibus autem quibusdam et aut officiis debitis aut rerum necessitatibus saepe eveniet ut et voluptates repudiandae sint et molestiae non recusandae. Itaque earum rerum hic tenetur a sapiente delectus, ut aut reiciendis voluptatibus maiores alias consequatur aut perferendis doloribus asperiores repellat.”\n\nTranslation by H. Rackham (1914)\n\n“On the other hand, we denounce with righteous indignation and dislike men who are so beguiled and demoralized by the charms of pleasure of the moment, so blinded by desire, that they cannot foresee the pain and trouble that are bound to ensue; and equal blame belongs to those who fail in their duty through weakness of will, which is the same as saying through shrinking from toil and pain. These cases are perfectly simple and easy to distinguish. In a free hour, when our power of choice is untrammelled and when nothing prevents our being able to do what we like best, every pleasure is to be welcomed and every pain avoided. But in certain circumstances and owing to the claims of duty or the obligations of business it will frequently occur that pleasures have to be repudiated and annoyances accepted. The wise man therefore always holds in these matters to this principle of selection: he rejects pleasures to secure other greater pleasures, or else he endures pains to avoid worse pains.”\n"
} ,
  
  {
    "title"    : "Markup: Syntax Highlighting",
    "category" : "",
    "tags"     : " Highlight, Markdown",
    "url"      : "/algoguru/blogging/2014/08/08/Markup-Syntax-Highlighting.html",
    "date"     : "August 8, 2014",
    "excerpt"  : "Syntax highlighting1 is a feature that displays source code.\nThis feature facilitates writing in a structured language such as a programming language or a markup language as it makes import things visually distinct.\n\nGFM Code Blocks\n\nGitHub Flavor...",
  "content"  : "Syntax highlighting1 is a feature that displays source code.\nThis feature facilitates writing in a structured language such as a programming language or a markup language as it makes import things visually distinct.\n\nGFM Code Blocks\n\nGitHub Flavored Markdown fenced code blocks are supported. To modify styling and highlight colors edit /_sass/syntax.scss.\n\n#container {\n  float: left;\n  margin: 0 -240px 0 0;\n  width: 100%;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n.highlight {\n  margin: 0;\n  padding: 1em;\n  font-family: $monospace;\n  font-size: $type-size-7;\n  line-height: 1.8;\n}\n\n\n&amp;lt;nav class=&quot;pagination&quot; role=&quot;navigation&quot;&amp;gt;\n  {% if page.previous %}\n    &amp;lt;a href=&quot;{{ site.url }}{{ page.previous.url }}&quot; class=&quot;btn&quot; title=&quot;{{ page.previous.title }}&quot;&amp;gt;Previous article&amp;lt;/a&amp;gt;\n  {% endif %}\n  {% if page.next %}\n    &amp;lt;a href=&quot;{{ site.url }}{{ page.next.url }}&quot; class=&quot;btn&quot; title=&quot;{{ page.next.title }}&quot;&amp;gt;Next article&amp;lt;/a&amp;gt;\n  {% endif %}\n&amp;lt;/nav&amp;gt;&amp;lt;!-- /.pagination --&amp;gt;\n\n\nmodule Jekyll\n  class TagIndex &amp;lt; Page\n    def initialize(site, base, dir, tag)\n      @site = site\n      @base = base\n      @dir = dir\n      @name = &#39;index.html&#39;\n      self.process(@name)\n      self.read_yaml(File.join(base, &#39;_layouts&#39;), &#39;tag_index.html&#39;)\n      self.data[&#39;tag&#39;] = tag\n      tag_title_prefix = site.config[&#39;tag_title_prefix&#39;] || &#39;Tagged: &#39;\n      tag_title_suffix = site.config[&#39;tag_title_suffix&#39;] || &#39;&amp;amp;#8211;&#39;\n      self.data[&#39;title&#39;] = &quot;#{tag_title_prefix}#{tag}&quot;\n      self.data[&#39;description&#39;] = &quot;An archive of posts tagged #{tag}.&quot;\n    end\n  end\nend\n\n\nCode Blocks in Lists\n\nIndentation matters. Be sure the indent of the code block aligns with the first non-space character after the list item marker (e.g., 1.). Usually this will mean indenting 3 spaces instead of 4.\n\n\n  Do step 1.\n  \n    Now do this:\n\n    def print_hi(name)\n  puts &quot;Hi, #{name}&quot;\nend\nprint_hi(&#39;Tom&#39;)\n#=&amp;gt; prints &#39;Hi, Tom&#39; to STDOUT.\n    \n  \n  Now you can do this.\n\n\nGitHub Gist Embed\n\nAn example of a Gist embed below:\n\n\n\nHere is how it looks like:\n\n   &amp;lt;script src=&quot;https://gist.github.com/sylhare/dad7ed1ef3d13614c77c4ebadf8a11c3.js&quot;&amp;gt;\n   &amp;lt;/script&amp;gt;\n\n\n\n\n  \n    \n      Michael’s Rose, Minimal Mistakes &amp;#8617;\n    \n  \n\n"
} ,
  
  {
    "title"    : "Generate a table of content",
    "category" : "",
    "tags"     : " Kramdown, Customization",
    "url"      : "/algoguru/2013/12/12/Generate-a-table-of-content.html",
    "date"     : "December 12, 2013",
    "excerpt"  : "Using Kramdown GFM \n\n\n\n  Using Kramdown GFM     \n      Basic Usage\n    \n  \n  Using toc.js    \n      Customize with toc.js        \n          Use with this jekyll template\n        \n      \n      Basic Usage\n      How it would look like\n    \n  \n\n\nBasi...",
  "content"  : "Using Kramdown GFM \n\n\n\n  Using Kramdown GFM     \n      Basic Usage\n    \n  \n  Using toc.js    \n      Customize with toc.js        \n          Use with this jekyll template\n        \n      \n      Basic Usage\n      How it would look like\n    \n  \n\n\nBasic Usage\n\nYou need to put this at the beginning of the page where you want the table of content to be displayed\n\n* TOC\n{:toc}\n\n\nIt will then render the markdown and html titles (lines that begins with # or using the &amp;lt;h1&amp;gt;&amp;lt;/h1&amp;gt; tages)\n\nUsing toc.js\n\nDemo display of jekyll-table-of-contents by ghiculescu.\n\n\n\n\nCustomize with toc.js\n\ntoc.js stands for table of content, it is a js plugin that generates automatically a table of content of a post.\n\nUse with this jekyll template\n\nIf you want to customize the theme it is up to you, you can add the toc.js file into the asset &amp;gt; js and add it into the page.html layout with:\n\n&amp;lt;script src=&quot;/algoguru/assets/js/toc.js&quot; &amp;gt;&amp;lt;/script&amp;gt;\n\nThen you can use it as it is said on the repository.\n\nBasic Usage\n\nThe script requires jQuery. First, reference toc.js in templates where you would like to add the table of content. Then, create an HTML element wherever you want your table of contents to appear:\n\n&amp;lt;div id=&quot;toc&quot;&amp;gt;&amp;lt;/div&amp;gt;\n\n\nThen you put your post with titles and all like:\n\n## Title\n## Mid title 1\nThis is text on page one\n## Mid title 2\nThis is text for page two\n### Sub title 2.a\nSome more text\n\n\nThen at the end of your post, you call the .toc() function using:\n\n&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;\n$(document).ready(function() {\n    $(&#39;#toc&#39;).toc();\n});\n&amp;lt;/script&amp;gt;\n\n\nHow it would look like\n\nSo you can get a feel of it.\n\n\n\n\n\n\n\n\n"
} ,
  
  {
    "title"    : "Blogging with title ",
    "category" : "",
    "tags"     : " Test, Image",
    "url"      : "/algoguru/2013/10/18/blogging-with-title.html",
    "date"     : "October 18, 2013",
    "excerpt"  : "I am a BIG title\n\nThis is a very tiny tiny post with less than 250 letters.\n\n",
  "content"  : "I am a BIG title\n\nThis is a very tiny tiny post with less than 250 letters.\n\n"
} 
  
  ,
  
  {
  
  "title"    : "Ninja",
  "category" : "",
  "tags"     : " Lorem",
  "url"      : "/algoguru/portfolio/ninja",
  "date"     : "April 8, 2014",
  "excerpt"  : "\n\nSed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, \neaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. \nNemo enim ipsam voluptatem ...",
  "content"  : "\n\nSed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, \neaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. \nNemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, \nsed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. \nNeque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, \nadipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. \nUt enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? \nQuis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, \nvel illum qui dolorem eum fugiat quo voluptas nulla pariatur?\n\n"
  
} ,
  
  {
  
  "title"    : "Creative",
  "category" : "",
  "tags"     : " Ipsum",
  "url"      : "/algoguru/portfolio/safe",
  "date"     : "August 16, 2014",
  "excerpt"  : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, \ntotam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. \nNemo enim ipsam voluptatem qu...",
  "content"  : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, \ntotam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. \nNemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, \nsed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. \nNeque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, \nsed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. \nUt enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? \nQuis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, \nvel illum qui dolorem eum fugiat quo voluptas nulla pariatur?\n\nUse this area of the page to describe your project. \nThe icon above is part of a free icon set by Flat Icons.\n"
  
} ,
  
  {
  
  "title"    : "Circus",
  "category" : "",
  "tags"     : " Ipsum",
  "url"      : "/algoguru/portfolio/circus",
  "date"     : "September 1, 2014",
  "excerpt"  : "\n\nSed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, \neaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. \nNemo enim ipsam voluptatem ...",
  "content"  : "\n\nSed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, \neaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. \nNemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, \nsed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. \nNeque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, \nadipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. \nUt enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? \nQuis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, \nvel illum qui dolorem eum fugiat quo voluptas nulla pariatur?\n\n"
  
} ,
  
  {
  
  "title"    : "Tower of Hanoi",
  "category" : "",
  "tags"     : " ",
  "url"      : "/algoguru/portfolio/hanoi",
  "date"     : "September 1, 2014",
  "excerpt"  : "\n\nSed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, \neaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. \nNemo enim ipsam voluptatem ...",
  "content"  : "\n\nSed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, \neaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. \nNemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, \nsed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. \nNeque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, \nadipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. \nUt enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? \nQuis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, \nvel illum qui dolorem eum fugiat quo voluptas nulla pariatur?\n\n"
  
} ,
  
  {
  
  "title"    : "Tic tac toe",
  "category" : "",
  "tags"     : " ",
  "url"      : "/algoguru/portfolio/tictactoe",
  "date"     : "September 1, 2014",
  "excerpt"  : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, \ntotam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. \nNemo enim ipsam voluptatem qu...",
  "content"  : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, \ntotam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. \nNemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, \nsed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. \nNeque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, \nsed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. \nUt enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? \nQuis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, \nvel illum qui dolorem eum fugiat quo voluptas nulla pariatur?\n\nUse this area of the page to describe your project. \nThe icon above is part of a free icon set by Flat Icons.\n\n"
  
} ,
  
  {
  
  "title"    : "Cake",
  "category" : "",
  "tags"     : " Lorem, Ipsum",
  "url"      : "/algoguru/portfolio/cake",
  "date"     : "September 27, 2015",
  "excerpt"  : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, \ntotam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. \nNemo enim ipsam voluptatem qu...",
  "content"  : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, \ntotam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. \nNemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, \nsed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. \nNeque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, \nsed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. \nUt enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? \nQuis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, \nvel illum qui dolorem eum fugiat quo voluptas nulla pariatur?\n\nUse this area of the page to describe your project. \nThe icon above is part of a free icon set by Flat Icons.\n"
  
} ,
  
  {
  
  "title"    : "Jekyll",
  "category" : "",
  "tags"     : " ",
  "url"      : "/algoguru/portfolio/jekyllblog",
  "date"     : "May 26, 2017",
  "excerpt"  : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, \neaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. \nNemo enim ipsam voluptatem qu...",
  "content"  : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, \neaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. \nNemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, \nsed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. \nNeque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, \nadipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. \nUt enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? \nQuis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, \nvel illum qui dolorem eum fugiat quo voluptas nulla pariatur?\n\n"
  
} ,
  
  {
  
  "title"    : "Lorem Ipsum",
  "category" : "",
  "tags"     : " ",
  "url"      : "/algoguru/portfolio/submarine",
  "date"     : "September 3, 2017",
  "excerpt"  : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, \ntotam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. \nNemo enim ipsam voluptatem qu...",
  "content"  : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, \ntotam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. \nNemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, \nsed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. \nNeque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, \nsed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. \nUt enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? \nQuis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, \nvel illum qui dolorem eum fugiat quo voluptas nulla pariatur?\n\nUse this area of the page to describe your project. \nThe icon above is part of a free icon set by Flat Icons.\n"
  
} ,
  
  {
  
  "title"    : "Github",
  "category" : "",
  "tags"     : " Lorem",
  "url"      : "/algoguru/portfolio/gitlecture",
  "date"     : "October 20, 2017",
  "excerpt"  : "\n\nSed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, \neaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. \nNemo enim ipsam voluptatem ...",
  "content"  : "\n\nSed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, \neaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. \nNemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, \nsed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. \nNeque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, \nadipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. \nUt enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? \nQuis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, \nvel illum qui dolorem eum fugiat quo voluptas nulla pariatur?\n\n"
  
} 
  
]
